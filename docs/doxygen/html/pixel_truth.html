<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AeroDynControlRig: The Pixel Truth: Everything is Just Computing RGBA</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AeroDynControlRig
   </div>
   <div id="projectbrief">Flight control algorithm testbed with OpenGL 3D visualization and ImGui dashboard</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('pixel_truth.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">The Pixel Truth: Everything is Just Computing RGBA </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li></li>
<li></li>
</ul>
<ul>
<li>## The Fundamental Truth</li>
</ul>
<ul>
<li><b>A pixel has exactly 2 pieces of information:</b></li>
<li>1. <b>Position</b>: (x, y) - which pixel in the grid</li>
<li>2. <b>Color</b>: (R, G, B, A) - red, green, blue, alpha (0-255 each)</li>
</ul>
<ul>
<li><b>That's it. Nothing else can be stored in a pixel.</b></li>
</ul>
<ul>
<li>Everything in graphics - shaders, vertices, VBO, VAO, lighting, shadows, reflections,</li>
<li>global illumination - is just <b>different ways to COMPUTE what RGBA value to put in each pixel</b>.</li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## The Only Thing That Matters: The Framebuffer</li>
</ul>
<ul>
<li>```</li>
<li>Framebuffer (1920×1080):</li>
<li>A 2D array of pixels. Each pixel stores:</li>
<li>- R (red): 0-255</li>
<li>- G (green): 0-255</li>
<li>- B (blue): 0-255</li>
<li>- A (alpha): 0-255</li>
</ul>
<ul>
<li>Example:</li>
<li>framebuffer[500][300] = (255, 0, 0, 255) ← Red pixel at position (500, 300)</li>
<li>framebuffer[501][300] = (0, 255, 0, 255) ← Green pixel at position (501, 300)</li>
<li>framebuffer[502][300] = (0, 0, 255, 255) ← Blue pixel at position (502, 300)</li>
<li>```</li>
</ul>
<ul>
<li><b>This is sent to the monitor. The monitor displays it. Done.</b></li>
</ul>
<ul>
<li>Everything else is just: "How do we compute what RGBA values to put in this array?"</li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## The Question Graphics Solves</li>
</ul>
<ul>
<li><b>Given</b>:</li>
<li>- A 3D scene (cube, lighting, camera position)</li>
<li>- A 2D screen (1920×1080 pixels)</li>
</ul>
<ul>
<li><b>Compute</b>:</li>
<li>- For EVERY pixel, what RGBA should it be?</li>
</ul>
<ul>
<li>```</li>
<li>Input: 3D scene with cube</li>
<li>Output: framebuffer[1920][1080] filled with RGBA values</li>
</ul>
<ul>
<li>framebuffer[0][0] = ? ← What color should top-left pixel be?</li>
<li>framebuffer[1][0] = ? ← What color should next pixel be?</li>
<li>...</li>
<li>framebuffer[1919][1079] = ? ← What color should bottom-right pixel be?</li>
<li>```</li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## Everything is Just RGBA Computation</li>
</ul>
<ul>
<li>Let's map every graphics concept to: "How does this help compute RGBA?"</li>
</ul>
<ul>
<li>### Vertices - Describe Shape Boundaries</li>
</ul>
<ul>
<li>```cpp</li>
<li>float vertices[] = {</li>
<li>-0.5f, -0.5f, -0.5f, // Corner 1 of cube</li>
<li>0.5f, -0.5f, -0.5f, // Corner 2 of cube</li>
<li>0.5f, 0.5f, -0.5f, // Corner 3 of cube</li>
<li>};</li>
<li>```</li>
</ul>
<ul>
<li><b>Purpose</b>: Define the <b>boundaries</b> of shapes in 3D space.</li>
</ul>
<ul>
<li><b>How it helps compute RGBA</b>:</li>
<li>- Vertices define triangles</li>
<li>- Triangles define "which pixels are inside the shape"</li>
<li>- Only pixels INSIDE get colored</li>
<li>- Pixels OUTSIDE stay as background</li>
</ul>
<ul>
<li>```</li>
<li>Triangle vertices: (100, 100), (200, 100), (150, 200)</li>
</ul>
<ul>
<li>Rasterizer asks: "Which pixels are inside this triangle?"</li>
<li>Pixel (125, 125)? → YES, inside → Run shader to compute RGBA</li>
<li>Pixel (50, 50)? → NO, outside → Don't compute, leave as background</li>
<li>Pixel (150, 150)? → YES, inside → Run shader to compute RGBA</li>
<li>```</li>
</ul>
<ul>
<li><b>Vertices don't appear in the final image - they just determine which pixels to color.</b></li>
</ul>
<ul>
<li>### VBO - Storage for Vertex Data</li>
</ul>
<ul>
<li>```cpp</li>
<li>glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</li>
<li>```</li>
</ul>
<ul>
<li><b>Purpose</b>: Store vertex data in GPU memory (VRAM).</li>
</ul>
<ul>
<li><b>How it helps compute RGBA</b>:</li>
<li>- GPU needs fast access to vertices</li>
<li>- GPU reads VBO to know "what triangles exist"</li>
<li>- Triangles determine "which pixels to process"</li>
<li>- Only pixels inside triangles get RGBA computed</li>
</ul>
<ul>
<li><b>VBO is just a storage optimization - data could be sent every frame, but that's slow.</b></li>
</ul>
<ul>
<li>### VAO - Format Description</li>
</ul>
<ul>
<li>```cpp</li>
<li>glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);</li>
<li>```</li>
</ul>
<ul>
<li><b>Purpose</b>: Tell GPU "how to read the VBO data".</li>
</ul>
<ul>
<li><b>How it helps compute RGBA</b>:</li>
<li>- GPU needs to know: "First 3 floats = position, next 3 floats = color"</li>
<li>- Reads position to know where triangle is</li>
<li>- Reads color to pass to shader</li>
<li>- Shader uses color to compute final RGBA</li>
</ul>
<ul>
<li>```</li>
<li>VBO: [x, y, z, r, g, b, x, y, z, r, g, b, ...]</li>
<li>↑</li>
<li>VAO: "First 3 = position (x,y,z), next 3 = color (r,g,b), stride = 6 floats"</li>
</ul>
<ul>
<li>GPU uses this to extract:</li>
<li>Vertex 0: position = (x, y, z), color = (r, g, b)</li>
<li>→ Pass to shader to compute RGBA for pixels inside this triangle</li>
<li>```</li>
</ul>
<ul>
<li><b>VAO doesn't affect RGBA - it just helps GPU parse the VBO correctly.</b></li>
</ul>
<ul>
<li>### Shaders - The RGBA Computation Logic</li>
</ul>
<ul>
<li><b>Vertex Shader</b> - Transforms vertices to screen space:</li>
</ul>
<ul>
<li>```glsl</li>
<li>// Input: 3D position from VBO</li>
<li>layout (location = 0) in vec3 aPos;</li>
</ul>
<ul>
<li>void <a class="el" href="main_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a> {</li>
<li>// Convert 3D world position to 2D screen position</li>
<li>gl_Position = projection * view * model * vec4(aPos, 1.0);</li>
<li>}</li>
<li>```</li>
</ul>
<ul>
<li><b>How it helps compute RGBA</b>:</li>
<li>- Takes 3D vertex position (-0.5, -0.5, -0.5)</li>
<li>- Applies camera transformation</li>
<li>- Outputs 2D screen position (500, 300)</li>
<li>- This tells GPU: "This triangle covers pixels near (500, 300)"</li>
</ul>
<ul>
<li><b>Still doesn't compute RGBA! Just positions triangles on screen.</b></li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li><b>Fragment Shader</b> - <b>THIS COMPUTES RGBA!</b></li>
</ul>
<ul>
<li>```glsl</li>
<li>// This runs ONCE per pixel</li>
<li>in vec3 fragColor; // Interpolated from vertices</li>
<li>out vec4 finalColor;</li>
</ul>
<ul>
<li>void <a class="el" href="main_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a> {</li>
<li>// COMPUTE the RGBA for this pixel</li>
<li>finalColor = vec4(fragColor, 1.0);</li>
<li>// GPU writes: framebuffer[pixel_x][pixel_y] = (R, G, B, A)</li>
<li>}</li>
<li>```</li>
</ul>
<ul>
<li><b>THIS IS WHERE RGBA IS COMPUTED!</b></li>
</ul>
<ul>
<li>Every pixel inside a triangle runs this shader.</li>
<li>The shader's output (<code>finalColor</code>) is written to the framebuffer.</li>
</ul>
<ul>
<li>```</li>
<li>Pixel at (500, 300):</li>
<li>Fragment shader runs:</li>
<li>fragColor = (1.0, 0.0, 0.0) ← Red, interpolated from vertices</li>
<li>finalColor = vec4(1.0, 0.0, 0.0, 1.0)</li>
<li>GPU writes:</li>
<li>framebuffer[500][300] = (255, 0, 0, 255)</li>
<li>```</li>
</ul>
<ul>
<li><b>Finally! We computed RGBA for a pixel!</b></li>
</ul>
<ul>
<li>### Lighting - More Complex RGBA Computation</li>
</ul>
<ul>
<li>```glsl</li>
<li>// Fragment shader with lighting</li>
<li>uniform vec3 lightPos;</li>
<li>in vec3 fragNormal;</li>
<li>in vec3 fragPos;</li>
</ul>
<ul>
<li>void <a class="el" href="main_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a> {</li>
<li>// COMPUTE how much light hits this pixel</li>
<li>vec3 lightDir = normalize(lightPos - fragPos);</li>
<li>float brightness = dot(fragNormal, lightDir);</li>
</ul>
<ul>
<li>// COMPUTE final RGBA based on lighting</li>
<li>vec3 baseColor = vec3(1.0, 0.0, 0.0); // Red</li>
<li>vec3 litColor = baseColor * brightness;</li>
<li>finalColor = vec4(litColor, 1.0);</li>
</ul>
<ul>
<li>// GPU writes computed RGBA to framebuffer</li>
<li>}</li>
<li>```</li>
</ul>
<ul>
<li><b>How it helps compute RGBA</b>:</li>
<li>- Uses light position and surface normal</li>
<li>- Computes "how bright should this pixel be?"</li>
<li>- Multiplies base color by brightness</li>
<li>- Outputs final RGBA</li>
</ul>
<ul>
<li>```</li>
<li>Pixel at (500, 300):</li>
<li>Facing light? → brightness = 0.8</li>
<li>Base color: (1.0, 0.0, 0.0) red</li>
<li>Lit color: (0.8, 0.0, 0.0) darker red</li>
<li>framebuffer[500][300] = (204, 0, 0, 255)</li>
</ul>
<ul>
<li>Pixel at (600, 400):</li>
<li>Facing away from light? → brightness = 0.2</li>
<li>Base color: (1.0, 0.0, 0.0) red</li>
<li>Lit color: (0.2, 0.0, 0.0) very dark red</li>
<li>framebuffer[600][400] = (51, 0, 0, 255)</li>
<li>```</li>
</ul>
<ul>
<li><b>Lighting just changes HOW we compute RGBA. Still ends up as (R, G, B, A) in framebuffer.</b></li>
</ul>
<ul>
<li>### Textures - Lookup Table for RGBA</li>
</ul>
<ul>
<li>```glsl</li>
<li>uniform sampler2D textureSampler;</li>
<li>in vec2 fragTexCoord; // (u, v) from 0.0 to 1.0</li>
</ul>
<ul>
<li>void <a class="el" href="main_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a> {</li>
<li>// LOOKUP RGBA from texture image</li>
<li>vec4 texColor = texture(textureSampler, fragTexCoord);</li>
<li>finalColor = texColor;</li>
<li>// GPU writes looked-up RGBA to framebuffer</li>
<li>}</li>
<li>```</li>
</ul>
<ul>
<li><b>How it helps compute RGBA</b>:</li>
<li>- Texture is a 2D image (e.g., 512×512 pixels with RGBA)</li>
<li>- Stored in GPU memory</li>
<li>- Fragment shader "looks up" RGBA from texture</li>
<li>- Uses texture coordinates (u, v) to find which texel (texture pixel)</li>
</ul>
<ul>
<li>```</li>
<li>Pixel at (500, 300):</li>
<li>Texture coordinate: (0.25, 0.75)</li>
<li>Lookup texture[128, 384]: (120, 80, 50, 255) ← Wood color</li>
<li>framebuffer[500][300] = (120, 80, 50, 255)</li>
</ul>
<ul>
<li>Pixel at (501, 300):</li>
<li>Texture coordinate: (0.26, 0.75)</li>
<li>Lookup texture[133, 384]: (125, 85, 55, 255) ← Slightly different wood</li>
<li>framebuffer[501][300] = (125, 85, 55, 255)</li>
<li>```</li>
</ul>
<ul>
<li><b>Texture is just a pre-computed RGBA lookup table.</b></li>
</ul>
<ul>
<li>### Shadows - Conditional RGBA Darkening</li>
</ul>
<ul>
<li>```glsl</li>
<li>uniform sampler2D shadowMap; // Depth texture from light's perspective</li>
</ul>
<ul>
<li>void <a class="el" href="main_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a> {</li>
<li>// Is this pixel in shadow?</li>
<li>float shadowDepth = texture(shadowMap, shadowCoord).r;</li>
<li>bool inShadow = (currentDepth &gt; shadowDepth);</li>
</ul>
<ul>
<li>// COMPUTE RGBA based on shadow</li>
<li>vec3 baseColor = vec3(1.0, 0.0, 0.0);</li>
<li>vec3 finalColor = inShadow ? baseColor * 0.3 : baseColor;</li>
<li>FragColor = vec4(finalColor, 1.0);</li>
<li>}</li>
<li>```</li>
</ul>
<ul>
<li><b>How it helps compute RGBA</b>:</li>
<li>- Shadow map stores depth from light's view</li>
<li>- Fragment shader checks: "Can light see this pixel?"</li>
<li>- If blocked (in shadow): darken RGBA</li>
<li>- If visible: normal RGBA</li>
</ul>
<ul>
<li>```</li>
<li>Pixel at (500, 300):</li>
<li>In shadow? → YES</li>
<li>Base: (255, 0, 0)</li>
<li>Darkened: (255 * 0.3, 0, 0) = (76, 0, 0)</li>
<li>framebuffer[500][300] = (76, 0, 0, 255)</li>
<li>```</li>
</ul>
<ul>
<li><b>Shadows just multiply RGBA by a darker value. Still ends up as RGBA.</b></li>
</ul>
<ul>
<li>### Global Illumination - Even More Complex RGBA Computation</li>
</ul>
<ul>
<li>```glsl</li>
<li>// Extremely simplified</li>
<li>void <a class="el" href="main_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a> {</li>
<li>// Direct lighting</li>
<li>vec3 direct = computeDirectLight();</li>
</ul>
<ul>
<li>// Indirect lighting (light bouncing from other surfaces)</li>
<li>vec3 indirect = computeIndirectLight(); // Very expensive!</li>
</ul>
<ul>
<li>// Ambient occlusion (corners are darker)</li>
<li>float ao = computeAmbientOcclusion();</li>
</ul>
<ul>
<li>// COMPUTE final RGBA</li>
<li>vec3 finalColor = (direct + indirect) * ao;</li>
<li>FragColor = vec4(finalColor, 1.0);</li>
<li>}</li>
<li>```</li>
</ul>
<ul>
<li><b>How it helps compute RGBA</b>:</li>
<li>- Traces light bouncing around the scene</li>
<li>- Computes accumulated light at this pixel</li>
<li>- More realistic, but much more computation</li>
</ul>
<ul>
<li>```</li>
<li>Pixel at (500, 300):</li>
<li>Direct light: (0.5, 0.0, 0.0)</li>
<li>Bounce from blue wall: (0.0, 0.0, 0.1)</li>
<li>Ambient occlusion: 0.8 (slightly occluded)</li>
<li>Final: (0.5 + 0.0, 0.0 + 0.0, 0.0 + 0.1) * 0.8 = (0.4, 0.0, 0.08)</li>
<li>framebuffer[500][300] = (102, 0, 20, 255)</li>
<li>```</li>
</ul>
<ul>
<li><b>Global illumination is VERY expensive RGBA computation. But still: just RGBA.</b></li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## The Complete Mapping</li>
</ul>
<ul>
<li>```</li>
<li>┌─────────────────────────────────────────────────────────────┐</li>
<li>│ GOAL: Fill framebuffer with RGBA values │</li>
<li>└─────────────────────────────────────────────────────────────┘</li>
<li>↑</li>
<li>┌───────────────┴────────────────┐</li>
<li>│ │</li>
<li>What to compute? How to compute it?</li>
<li>│ │</li>
<li>↓ ↓</li>
<li>┌──────────────────┐ ┌──────────────────────┐</li>
<li>│ Geometry │ │ Shaders │</li>
<li>│ (Vertices) │ │ (RGBA computation) │</li>
<li>│ │ │ │</li>
<li>│ Purpose: │ │ Purpose: │</li>
<li>│ Define which │ │ Compute RGBA for │</li>
<li>│ pixels to color │ │ each pixel │</li>
<li>│ │ │ │</li>
<li>│ Triangle at: │ │ Simple: │</li>
<li>│ (100,100), │ │ return red; │</li>
<li>│ (200,100), │ │ │</li>
<li>│ (150,200) │ │ Lighting: │</li>
<li>│ ↓ │ │ return red * light;│</li>
<li>│ Covers 5000 │ │ │</li>
<li>│ pixels │ │ Texture: │</li>
<li>│ ↓ │ │ return texture(); │</li>
<li>│ Run shader │ │ │</li>
<li>│ 5000 times │ │ Shadows: │</li>
<li>└────────┬─────────┘ │ return darkened; │</li>
<li>│ │ │</li>
<li>│ │ Global Illumination: │</li>
<li>│ │ return bounced; │</li>
<li>│ └──────────┬───────────┘</li>
<li>│ │</li>
<li>└────────────┬───────────────────┘</li>
<li>↓</li>
<li>┌──────────────────────┐</li>
<li>│ Fragment Shader │</li>
<li>│ Runs per pixel │</li>
<li>│ Outputs RGBA │</li>
<li>└──────────┬───────────┘</li>
<li>↓</li>
<li>┌──────────────────────┐</li>
<li>│ Framebuffer │</li>
<li>│ [x][y] = (R,G,B,A) │</li>
<li>└──────────┬───────────┘</li>
<li>↓</li>
<li>┌──────────────────────┐</li>
<li>│ Monitor │</li>
<li>│ Displays pixels │</li>
<li>└──────────────────────┘</li>
<li>```</li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## Mental Model: The Two-Step Process</li>
</ul>
<ul>
<li>### Step 1: Which Pixels? (Geometry)</li>
</ul>
<ul>
<li><b>Input</b>: Vertices (triangles)</li>
<li><b>Process</b>: Rasterization</li>
<li><b>Output</b>: List of pixel coordinates to process</li>
</ul>
<ul>
<li>```</li>
<li>Vertices define triangle: (100,100), (200,100), (150,200)</li>
<li>↓ Rasterizer</li>
<li>Pixel list: (100,100), (101,100), (102,100), ..., (150,175), ... (5000 pixels)</li>
<li>```</li>
</ul>
<ul>
<li><b>VBO, VAO, vertex shader - all part of this step.</b></li>
</ul>
<ul>
<li>### Step 2: What RGBA? (Shading)</li>
</ul>
<ul>
<li><b>Input</b>: List of pixels from Step 1</li>
<li><b>Process</b>: Fragment shader (YOUR code!)</li>
<li><b>Output</b>: RGBA for each pixel</li>
</ul>
<ul>
<li>```</li>
<li>For pixel (125, 135):</li>
<li>Fragment shader runs:</li>
<li>vec4 color = computeColor(); ← YOUR logic here</li>
<li>return color;</li>
<li>↓</li>
<li>framebuffer[125][135] = (R, G, B, A)</li>
<li>```</li>
</ul>
<ul>
<li><b>Everything else (lighting, textures, shadows, GI) - just ways to compute RGBA.</b></li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## Why This Matters</li>
</ul>
<ul>
<li>Understanding "it's all just RGBA" clarifies:</li>
</ul>
<ul>
<li>### 1. Why shaders are so powerful</li>
</ul>
<ul>
<li>You control the RGBA computation:</li>
<li>```glsl</li>
<li>// Simple: solid color</li>
<li>FragColor = vec4(1.0, 0.0, 0.0, 1.0);</li>
</ul>
<ul>
<li>// Complex: realistic lighting</li>
<li>FragColor = computePhysicallyBasedLighting();</li>
</ul>
<ul>
<li>// Artistic: toon shading</li>
<li>FragColor = quantize(color); // Cel shading</li>
<li>```</li>
</ul>
<ul>
<li>### 2. Why GPUs are so fast</li>
</ul>
<ul>
<li>2 million pixels need RGBA computed.</li>
<li>GPU runs fragment shader 2 million times in parallel.</li>
<li>All writing to different framebuffer locations - no conflicts!</li>
</ul>
<ul>
<li>### 3. Why framebuffers exist</li>
</ul>
<ul>
<li>You can't write to the monitor directly.</li>
<li>Framebuffer is the intermediate RGBA storage.</li>
<li>GPU fills it, display engine reads it.</li>
</ul>
<ul>
<li>### 4. Why vertices matter</li>
</ul>
<ul>
<li>Without vertices, GPU doesn't know WHICH pixels to compute RGBA for.</li>
<li>Vertices define the geometry boundaries.</li>
</ul>
<ul>
<li>### 5. Why VBO/VAO are just optimization</li>
</ul>
<ul>
<li>They don't affect RGBA directly.</li>
<li>They just make accessing vertex data faster.</li>
<li>Faster access → faster "which pixels?" step → faster rendering.</li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## The Simplest Possible <a class="el" href="classRenderer.html" title="OpenGL 3.3 renderer for the main 3D scene.">Renderer</a></li>
</ul>
<ul>
<li>If you could write to framebuffer directly (you can't in OpenGL, but conceptually):</li>
</ul>
<ul>
<li>```cpp</li>
<li>// Direct pixel writing (pseudo-code)</li>
<li>for (int y = 0; y &lt; 1080; y++) {</li>
<li>for (int x = 0; x &lt; 1920; x++) {</li>
<li>// Compute RGBA for this pixel</li>
<li>RGBA color = myComputeFunction(x, y);</li>
<li>framebuffer[x][y] = color;</li>
<li>}</li>
<li>}</li>
<li>sendToMonitor(framebuffer);</li>
<li>```</li>
</ul>
<ul>
<li><b>That's it! That's all rendering is!</b></li>
</ul>
<ul>
<li>Everything in OpenGL is just making this faster:</li>
<li>- Vertices: Skip pixels outside shapes</li>
<li>- VBO: Fast vertex access</li>
<li>- VAO: Efficient vertex format parsing</li>
<li>- Shaders: Parallel RGBA computation on GPU</li>
<li>- Textures: Pre-computed color lookup</li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## The Ultimate Truth: It's All Just a Function</li>
</ul>
<ul>
<li>Every rendering technique, no matter how complex, is just:</li>
</ul>
<ul>
<li>```cpp</li>
<li>// The universal signature of ALL graphics:</li>
<li>RGBA compute_pixel_color(int x, int y);</li>
</ul>
<ul>
<li>// Different techniques = different implementations</li>
</ul>
<ul>
<li>// Technique 1: Flat color (trivial)</li>
<li>RGBA compute_pixel_color(int x, int y) {</li>
<li>return {255, 0, 0, 255}; // Always red</li>
<li>}</li>
</ul>
<ul>
<li>// Technique 2: Texture lookup (simple)</li>
<li>RGBA compute_pixel_color(int x, int y) {</li>
<li>vec2 uv = calculate_uv(x, y);</li>
<li>return texture_lookup(button_image, uv);</li>
<li>}</li>
</ul>
<ul>
<li>// Technique 3: Phong lighting (medium)</li>
<li>RGBA compute_pixel_color(int x, int y) {</li>
<li>vec3 normal = get_surface_normal(x, y);</li>
<li>vec3 light_dir = normalize(light_pos - pixel_pos);</li>
<li>float brightness = dot(normal, light_dir);</li>
<li>return base_color * brightness;</li>
<li>}</li>
</ul>
<ul>
<li>// Technique 4: Ray tracing (complex)</li>
<li>RGBA compute_pixel_color(int x, int y) {</li>
<li>Ray ray = create_ray_from_camera_through_pixel(x, y);</li>
<li>Object hit = trace_ray(ray);</li>
</ul>
<ul>
<li>if (hit.exists) {</li>
<li>vec3 color = hit.material.color;</li>
</ul>
<ul>
<li>// Shadow ray</li>
<li>Ray shadow_ray = create_ray_to_light(hit.point);</li>
<li>if (is_blocked(shadow_ray)) {</li>
<li>color *= 0.3; // Darken</li>
<li>}</li>
</ul>
<ul>
<li>// Reflection ray</li>
<li>Ray reflection = reflect(ray, hit.normal);</li>
<li>vec3 reflected_color = trace_ray(reflection);</li>
<li>color = blend(color, reflected_color, hit.material.reflectivity);</li>
</ul>
<ul>
<li>return to_rgba(color);</li>
<li>}</li>
<li>return {0, 0, 0, 255}; // Black background</li>
<li>}</li>
</ul>
<ul>
<li>// Technique 5: Path tracing (very complex)</li>
<li>RGBA compute_pixel_color(int x, int y) {</li>
<li>vec3 accumulated_color = {0, 0, 0};</li>
</ul>
<ul>
<li>// Sample many rays for noise reduction</li>
<li>for (int sample = 0; sample &lt; 1000; sample++) {</li>
<li>Ray ray = create_ray_from_camera(x, y, random_offset());</li>
</ul>
<ul>
<li>// Bounce ray multiple times</li>
<li>for (int bounce = 0; bounce &lt; 10; bounce++) {</li>
<li>Object hit = trace_ray(ray);</li>
<li>if (!hit.exists) break;</li>
</ul>
<ul>
<li>// Accumulate light contribution</li>
<li>accumulated_color += hit.emission;</li>
</ul>
<ul>
<li>// Bounce in random direction (Monte Carlo)</li>
<li>ray = create_random_bounce(hit.point, hit.normal);</li>
<li>}</li>
<li>}</li>
</ul>
<ul>
<li>// Average all samples</li>
<li>accumulated_color /= 1000;</li>
<li>return to_rgba(accumulated_color);</li>
<li>}</li>
<li>```</li>
</ul>
<ul>
<li><b>Same signature. Same output. Different computation complexity.</b></li>
</ul>
<ul>
<li>```</li>
<li>ALL TECHNIQUES CONVERGE TO THE SAME THING:</li>
</ul>
<ul>
<li>Flat Color ───┐</li>
<li>Texture ──────┤</li>
<li>Phong ────────┼──→ framebuffer[y][x] = {R, G, B, A} ──→ Monitor</li>
<li>Ray Tracing ──┤</li>
<li>Path Tracing ─┘</li>
</ul>
<ul>
<li>COMPLEXITY COMPARISON:</li>
<li>Flat: 1 operation per pixel</li>
<li>Texture: ~10 operations per pixel</li>
<li>Phong: ~100 operations per pixel</li>
<li>Ray Tracing: ~10,000 operations per pixel</li>
<li>Path Tracing: ~100,000,000 operations per pixel</li>
</ul>
<ul>
<li>OUTPUT: All produce 4 bytes (RGBA)</li>
<li>```</li>
</ul>
<ul>
<li><b>Why does complexity matter?</b></li>
</ul>
<ul>
<li>Higher complexity = more realistic lighting:</li>
<li>- Flat: Looks like a cartoon</li>
<li>- Phong: Looks like a video game from 2005</li>
<li>- Ray tracing: Looks like a modern AAA game</li>
<li>- Path tracing: Looks like a photograph (if you wait long enough!)</li>
</ul>
<ul>
<li>But the framebuffer doesn't care. It just stores RGBA.</li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## The Rendering Loop (All Techniques)</li>
</ul>
<ul>
<li>```cpp</li>
<li>// Pseudocode for ALL rendering, regardless of technique:</li>
</ul>
<ul>
<li>void render_frame() {</li>
<li>// Step 1: Clear framebuffer</li>
<li>for (int y = 0; y &lt; HEIGHT; y++) {</li>
<li>for (int x = 0; x &lt; WIDTH; x++) {</li>
<li>framebuffer[y][x] = {0, 0, 0, 255}; // Black</li>
<li>}</li>
<li>}</li>
</ul>
<ul>
<li>// Step 2: For each object, determine which pixels it covers</li>
<li>for (Object obj : scene) {</li>
<li>PixelList pixels = rasterize(obj); // Which pixels?</li>
</ul>
<ul>
<li>// Step 3: For each pixel, compute color</li>
<li>for (Pixel p : pixels) {</li>
<li>RGBA color = compute_pixel_color(p.x, p.y);</li>
<li>framebuffer[p.y][p.x] = color;</li>
<li>}</li>
<li>}</li>
</ul>
<ul>
<li>// Step 4: Send to monitor</li>
<li>send_to_display(framebuffer);</li>
<li>}</li>
</ul>
<ul>
<li>// The ONLY thing that changes between techniques is:</li>
<li>// compute_pixel_color(x, y)</li>
<li>//</li>
<li>// Everything else is the same!</li>
<li>```</li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## What About VBO, VAO, Shaders?</li>
</ul>
<ul>
<li>They're all just <b>implementation details</b> of the two core operations:</li>
</ul>
<ul>
<li>### Operation 1: "Which pixels to process?"</li>
</ul>
<ul>
<li>```</li>
<li>Vertices ──→ VBO (storage) ──→ VAO (format) ──→ Vertex Shader (position)</li>
<li>↓</li>
<li>Rasterizer</li>
<li>↓</li>
<li>List of (x,y) coordinates</li>
<li>```</li>
</ul>
<ul>
<li><b>Result:</b> List of pixel coordinates to color</li>
</ul>
<ul>
<li>### Operation 2: "What color for each pixel?"</li>
</ul>
<ul>
<li>```</li>
<li>Fragment Shader (YOUR CODE):</li>
<li>input: (x, y)</li>
<li>output: (R, G, B, A)</li>
</ul>
<ul>
<li>Executed in parallel by GPU for all pixels.</li>
<li>```</li>
</ul>
<ul>
<li><b>Result:</b> RGBA value for each pixel</li>
</ul>
<ul>
<li>### They Combine:</li>
</ul>
<ul>
<li>```</li>
<li>for (Pixel p : rasterized_pixels) {</li>
<li>framebuffer[p.y][p.x] = fragment_shader(p.x, p.y);</li>
<li>}</li>
<li>```</li>
</ul>
<ul>
<li><b>That's it. That's ALL rendering.</b></li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## Why GPUs Are Fast</li>
</ul>
<ul>
<li>Because this loop:</li>
<li>```cpp</li>
<li>for (int i = 0; i &lt; 2_000_000; i++) {</li>
<li>framebuffer[i] = compute_pixel_color(i);</li>
<li>}</li>
<li>```</li>
</ul>
<ul>
<li>Can be parallelized:</li>
<li>```</li>
<li>CPU (8 cores):</li>
<li>Core 0: framebuffer[0..250000] = compute...</li>
<li>Core 1: framebuffer[250001..500000] = compute...</li>
<li>...</li>
<li>Core 7: framebuffer[1750000..2000000] = compute...</li>
</ul>
<ul>
<li>Still slow - only 8 pixels at once.</li>
</ul>
<ul>
<li>GPU (96 execution units × 7 threads = 672 parallel):</li>
<li>EU 0: framebuffer[0..2975] = compute...</li>
<li>EU 1: framebuffer[2976..5951] = compute...</li>
<li>...</li>
<li>EU 95: framebuffer[285714..288689] = compute...</li>
</ul>
<ul>
<li>672 pixels computed simultaneously!</li>
<li>```</li>
</ul>
<ul>
<li><b>GPU does the SAME work, just in parallel.</b></li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## The Complete Mental Model</li>
</ul>
<ul>
<li>```</li>
<li>┌─────────────────────────────────────────────────────┐</li>
<li>│ YOUR GOAL: Fill this 2D array │</li>
<li>│ │</li>
<li>│ framebuffer[1080][1920] = { │</li>
<li>│ {R, G, B, A}, {R, G, B, A}, ... (1920 pixels) │</li>
<li>│ {R, G, B, A}, {R, G, B, A}, ... (1920 pixels) │</li>
<li>│ ... (1080 rows) │</li>
<li>│ } │</li>
<li>└──────────────────┬──────────────────────────────────┘</li>
<li>│</li>
<li>┌──────────┴──────────┐</li>
<li>│ │</li>
<li>Question 1 Question 2</li>
<li>WHICH pixels? WHAT color?</li>
<li>│ │</li>
<li>↓ ↓</li>
<li>┌──────────┐ ┌──────────────┐</li>
<li>│ Geometry │ │ Shader │</li>
<li>│ (Vertices│ │ (Your │</li>
<li>│ VBO/VAO)│ │ RGBA logic) │</li>
<li>└────┬─────┘ └──────┬───────┘</li>
<li>│ │</li>
<li>↓ │</li>
<li>Rasterizer │</li>
<li>(GPU HW) │</li>
<li>│ │</li>
<li>↓ │</li>
<li>Pixel list: │</li>
<li>(100,100) ────────────────┐│</li>
<li>(101,100) ────────────────┤│</li>
<li>(102,100) ────────────────┤│</li>
<li>... ────────────────┤│</li>
<li>││</li>
<li>┌──────────────────────────┘│</li>
<li>│ For each pixel: │</li>
<li>│ RGBA = shader(x, y) ←───┘</li>
<li>│ framebuffer[y][x] = RGBA</li>
<li>└──────────┬────────────</li>
<li>↓</li>
<li>┌────────────────┐</li>
<li>│ Display Engine │</li>
<li>│ Reads 60Hz │</li>
<li>└───────┬────────┘</li>
<li>│ HDMI</li>
<li>↓</li>
<li>[Monitor]</li>
<li>```</li>
</ul>
<ul>
<li><b>Everything else is optimization or artistic choice.</b></li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## Summary</li>
</ul>
<ul>
<li>| Concept | Purpose | Affects RGBA? |</li>
<li>|------&mdash;|------&mdash;|------------&mdash;|</li>
<li>| <b>Vertices</b> | Define shape boundaries | No - determines WHICH pixels |</li>
<li>| <b>VBO</b> | Store vertices in VRAM | No - just storage optimization |</li>
<li>| <b>VAO</b> | Describe vertex format | No - just parsing metadata |</li>
<li>| <b>Vertex Shader</b> | <a class="el" href="classTransform.html">Transform</a> vertices to screen | No - just positioning |</li>
<li>| <b>Rasterizer</b> | Find pixels in triangles | No - just pixel list |</li>
<li>| <b>Fragment Shader</b> | <b>COMPUTE RGBA</b> | <b>YES! This is where RGBA comes from!</b> |</li>
<li>| <b>Textures</b> | Lookup pre-computed RGBA | Yes - provides input to shader |</li>
<li>| <b>Lighting</b> | Math for RGBA computation | Yes - multiplies/adds to RGBA |</li>
<li>| <b>Shadows</b> | Conditional RGBA darkening | Yes - modifies RGBA |</li>
<li>| <b>Global Illumination</b> | Complex RGBA math | Yes - advanced RGBA computation |</li>
<li>| <b>Framebuffer</b> | Store final RGBA | No - just storage |</li>
<li>| <b>Monitor</b> | Display RGBA | No - just display device |</li>
</ul>
<ul>
<li><b>Everything exists to answer two questions:</b></li>
<li>1. <b>Which pixels should have color?</b> (Vertices, rasterization)</li>
<li>2. <b>What RGBA should each pixel be?</b> (Fragment shader, everything else)</li>
</ul>
<ul>
<li>The framebuffer stores the answers. The monitor displays them.</li>
</ul>
<ul>
<li><b>That's all graphics is.</b></li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## See Also</li>
</ul>
<ul>
<li>- <a class="el" href="display_fundamentals.html">Display Fundamentals: Pixels, Framebuffers, and the OS</a> - How pixels get on screen</li>
<li>- <a class="el" href="hardware_pipeline.html">Hardware Pipeline: RAM → CPU → GPU → Screen</a> - Hardware execution flow</li>
<li>- <a class="el" href="opengl_tutorial.html">OpenGL Deep Dive Tutorial</a> - OpenGL API details */ </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
