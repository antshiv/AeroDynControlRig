<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AeroDynControlRig: Display Fundamentals: Pixels, Framebuffers, and the OS</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AeroDynControlRig
   </div>
   <div id="projectbrief">Flight control algorithm testbed with OpenGL 3D visualization and ImGui dashboard</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('display_fundamentals.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Display Fundamentals: Pixels, Framebuffers, and the OS </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li></li>
<li></li>
</ul>
<ul>
<li>Understanding graphics requires understanding the <b>fundamental problem</b>:</li>
<li>How do we put colored pixels on a monitor?</li>
</ul>
<ul>
<li>This guide explains the complete picture from the lowest level (physical pixels)</li>
<li>to the highest level (your application drawing a rectangle).</li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## Step 0: The Physical Monitor (The Target)</li>
</ul>
<ul>
<li>### What is a Monitor?</li>
</ul>
<ul>
<li>A monitor is a <b>grid of physical pixels</b> (light-emitting elements).</li>
</ul>
<ul>
<li>```</li>
<li>1920×1080 monitor = 2,073,600 individual pixels arranged in a grid:</li>
</ul>
<ul>
<li>Column: 0 1 2 3 ... 1919</li>
<li>┌──────┬──────┬──────┬──────────┐</li>
<li>Row 0: │Pixel │Pixel │Pixel │... │</li>
<li>├──────┼──────┼──────┼──────────┤</li>
<li>Row 1: │Pixel │Pixel │Pixel │... │</li>
<li>├──────┼──────┼──────┼──────────┤</li>
<li>Row 2: │Pixel │Pixel │Pixel │... │</li>
<li>│ ... ... ... │</li>
<li>Row 1079:│Pixel │Pixel │Pixel │... │</li>
<li>└──────┴──────┴──────┴──────────┘</li>
<li>```</li>
</ul>
<ul>
<li>Each pixel has <b>3 sub-pixels</b>: Red, Green, Blue (RGB).</li>
</ul>
<ul>
<li>Each sub-pixel can have brightness 0-255:</li>
<li>- (255, 0, 0) = bright red</li>
<li>- (0, 255, 0) = bright green</li>
<li>- (255, 255, 255) = white</li>
<li>- (0, 0, 0) = black</li>
</ul>
<ul>
<li>### How Does the Monitor Get Pixel Data?</li>
</ul>
<ul>
<li>The monitor is <b>completely dumb</b>. It just displays whatever pixel values it receives.</li>
</ul>
<ul>
<li>```</li>
<li>DisplayPort/HDMI cable sends a stream of pixel values 60 times per second:</li>
</ul>
<ul>
<li>Frame 1 (16.67ms duration):</li>
<li>Pixel[0,0] = (255, 0, 0) ← Red</li>
<li>Pixel[0,1] = (255, 0, 0) ← Red</li>
<li>Pixel[0,2] = (255, 0, 0) ← Red</li>
<li>... 2,073,597 more pixels</li>
</ul>
<ul>
<li>Frame 2 (next 16.67ms):</li>
<li>Pixel[0,0] = (0, 255, 0) ← Green (changed!)</li>
<li>Pixel[0,1] = (0, 255, 0) ← Green</li>
<li>Pixel[0,2] = (0, 255, 0) ← Green</li>
<li>... 2,073,597 more pixels</li>
<li>```</li>
</ul>
<ul>
<li><b>The monitor has no memory of what it displayed before.</b></li>
<li>You must send all 2+ million pixel values EVERY frame (60 times per second)!</li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## Step 1: The Framebuffer (2D Canvas in Memory)</li>
</ul>
<ul>
<li>### What is a Framebuffer?</li>
</ul>
<ul>
<li>A <b>framebuffer</b> is a <b>2D array in RAM</b> that holds pixel values for one frame.</li>
</ul>
<ul>
<li>```</li>
<li>For 1920×1080 display:</li>
</ul>
<ul>
<li>Framebuffer in memory (system RAM for integrated GPU):</li>
<li>Size = 1920 × 1080 × 4 bytes per pixel = 8,294,400 bytes (~8 MB)</li>
</ul>
<ul>
<li>Memory layout (linear array):</li>
<li>Address 0x80000000: [R, G, B, A] ← Pixel (0, 0)</li>
<li>Address 0x80000004: [R, G, B, A] ← Pixel (1, 0)</li>
<li>Address 0x80000008: [R, G, B, A] ← Pixel (2, 0)</li>
<li>...</li>
<li>Address 0x807E8000: [R, G, B, A] ← Pixel (1919, 1079) - last pixel</li>
<li>```</li>
</ul>
<ul>
<li><b>This is the 2D canvas you asked about!</b></li>
<li>- One framebuffer per monitor</li>
<li>- Stores RGBA for every pixel</li>
<li>- Lives in system RAM (for integrated GPU) or VRAM (for discrete GPU)</li>
</ul>
<ul>
<li>### Who Writes to the Framebuffer?</li>
</ul>
<ul>
<li><b>The GPU execution units write to it, pixel by pixel.</b></li>
</ul>
<ul>
<li>When the GPU runs your fragment shader, it writes the output color to the framebuffer:</li>
</ul>
<ul>
<li>```glsl</li>
<li>// Fragment shader runs ONCE per pixel</li>
<li>void <a class="el" href="main_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a> {</li>
<li>// Calculate color for this pixel</li>
<li>vec4 color = vec4(1.0, 0.0, 0.0, 1.0); // Red</li>
</ul>
<ul>
<li>// Output goes to framebuffer at this pixel's position</li>
<li>FragColor = color;</li>
<li>// GPU writes this to: framebuffer[pixel_x, pixel_y] = (255, 0, 0, 255)</li>
<li>}</li>
<li>```</li>
</ul>
<ul>
<li><b>The GPU fills the framebuffer pixel-by-pixel</b> based on your shaders!</li>
</ul>
<ul>
<li>### How Does the Monitor Get the Framebuffer?</li>
</ul>
<ul>
<li><b>Display Engine</b> (hardware on the CPU die) scans the framebuffer and sends it to the monitor:</li>
</ul>
<ul>
<li>```</li>
<li>Display Engine (60 Hz refresh):</li>
<li>Every 16.67ms:</li>
<li>1. Read framebuffer from RAM (all 8 MB)</li>
<li>2. Convert to DisplayPort/HDMI signal</li>
<li>3. Send to monitor pixel-by-pixel:</li>
<li>Row 0: send pixels 0-1919</li>
<li>Row 1: send pixels 0-1919</li>
<li>...</li>
<li>Row 1079: send pixels 0-1919</li>
<li>4. Monitor displays the frame</li>
<li>5. Repeat</li>
<li>```</li>
</ul>
<ul>
<li><b>The monitor just receives a stream of pixels - it has no idea what they represent!</b></li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## Step 2: How to Put One Pixel on Screen</li>
</ul>
<ul>
<li><b>You DON'T write code to set individual pixels</b> (usually).</li>
</ul>
<ul>
<li>Instead:</li>
<li>1. <b>You draw geometry</b> (triangles with vertices)</li>
<li>2. <b>GPU rasterizes</b> (converts triangles to pixels)</li>
<li>3. <b>GPU runs fragment shader</b> for each pixel</li>
<li>4. <b>Fragment shader outputs color</b> to framebuffer</li>
</ul>
<ul>
<li>### Example: Drawing One Red Pixel at (500, 300)</li>
</ul>
<ul>
<li><b>Method 1: Draw a tiny triangle covering that pixel</b></li>
</ul>
<ul>
<li>```cpp</li>
<li>// Create a triangle that covers pixel (500, 300)</li>
<li>float vertices[] = {</li>
<li>500.0f, 300.0f, // Vertex 0</li>
<li>501.0f, 300.0f, // Vertex 1</li>
<li>500.0f, 301.0f, // Vertex 2</li>
<li>};</li>
</ul>
<ul>
<li>// Upload to GPU</li>
<li>glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</li>
</ul>
<ul>
<li>// Draw</li>
<li>glDrawArrays(GL_TRIANGLES, 0, 3);</li>
<li>```</li>
</ul>
<ul>
<li><b>What happens</b>:</li>
<li>```</li>
<li>1. GPU receives 3 vertices: (500, 300), (501, 300), (500, 301)</li>
<li>2. Rasterizer finds pixels inside triangle: just (500, 300)</li>
<li>3. Fragment shader runs ONCE for pixel (500, 300)</li>
<li>4. Shader outputs red: (1.0, 0.0, 0.0, 1.0)</li>
<li>5. GPU writes to framebuffer[500, 300] = (255, 0, 0, 255)</li>
<li>6. Display engine sends this to monitor</li>
<li>7. Monitor lights up pixel at row 300, column 500 in red</li>
<li>```</li>
</ul>
<ul>
<li><b>Method 2: Use a library like ImGui</b></li>
</ul>
<ul>
<li>```cpp</li>
<li>// ImGui generates the triangle vertices for you</li>
<li>ImDrawList* draw_list = ImGui::GetWindowDrawList();</li>
<li>draw_list-&gt;AddRectFilled(ImVec2(500, 300), ImVec2(501, 301), IM_COL32(255, 0, 0, 255));</li>
</ul>
<ul>
<li>// ImGui backend uploads to GPU and draws</li>
<li>ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());</li>
<li>```</li>
</ul>
<ul>
<li><b>You NEVER write</b>: <code>framebuffer[500][300] = red;</code> directly.</li>
</ul>
<ul>
<li>You always go through: <b>Geometry → Rasterization → Fragment Shader → Framebuffer</b></li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## Step 3: Drawing a Rectangle (High-Level to Low-Level)</li>
</ul>
<ul>
<li>Let's trace: "Draw a green rectangle at (100, 100) with size 200×150"</li>
</ul>
<ul>
<li>### Your Code (High-Level)</li>
</ul>
<ul>
<li>```cpp</li>
<li>// Option 1: Pure OpenGL</li>
<li>float vertices[] = {</li>
<li>// Rectangle = 2 triangles = 6 vertices</li>
<li>100.0f, 100.0f, 0.0f, 1.0f, 0.0f, // Bottom-left, green</li>
<li>300.0f, 100.0f, 0.0f, 1.0f, 0.0f, // Bottom-right, green</li>
<li>300.0f, 250.0f, 0.0f, 1.0f, 0.0f, // Top-right, green</li>
<li>100.0f, 100.0f, 0.0f, 1.0f, 0.0f, // Bottom-left, green</li>
<li>300.0f, 250.0f, 0.0f, 1.0f, 0.0f, // Top-right, green</li>
<li>100.0f, 250.0f, 0.0f, 1.0f, 0.0f, // Top-left, green</li>
<li>};</li>
</ul>
<ul>
<li>glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</li>
<li>glDrawArrays(GL_TRIANGLES, 0, 6);</li>
<li>```</li>
</ul>
<ul>
<li>```cpp</li>
<li>// Option 2: ImGui (easier)</li>
<li>ImGui::GetBackgroundDrawList()-&gt;AddRectFilled(</li>
<li>ImVec2(100, 100),</li>
<li>ImVec2(300, 250),</li>
<li>IM_COL32(0, 255, 0, 255) // Green</li>
<li>);</li>
<li>```</li>
</ul>
<ul>
<li>### GPU Processing (Low-Level)</li>
</ul>
<ul>
<li>```</li>
<li>Step 1: Vertex Shader</li>
<li>Process 6 vertices (2 triangles):</li>
<li>Vertex 0: (100, 100) → screen position</li>
<li>Vertex 1: (300, 100) → screen position</li>
<li>... 4 more vertices</li>
</ul>
<ul>
<li>Step 2: Rasterizer</li>
<li>Find ALL pixels inside the 2 triangles:</li>
<li>Triangle 1: (100,100), (300,100), (300,250)</li>
<li>→ Covers pixels: (100,100), (101,100), (102,100), ..., (299,249)</li>
<li>Triangle 2: (100,100), (300,250), (100,250)</li>
<li>→ Covers pixels: (100,100), (101,100), ..., (100,249)</li>
</ul>
<ul>
<li>Total pixels to color: 200 × 150 = 30,000 pixels</li>
</ul>
<ul>
<li>Step 3: Fragment Shader (runs 30,000 times in parallel!)</li>
<li>For each pixel (e.g., pixel at 150, 175):</li>
<li>vec4 color = vec4(0.0, 1.0, 0.0, 1.0); // Green</li>
<li>FragColor = color;</li>
<li>// GPU writes: framebuffer[150, 175] = (0, 255, 0, 255)</li>
</ul>
<ul>
<li>Step 4: Framebuffer Now Contains</li>
<li>framebuffer[100][100] = (0, 255, 0, 255) ← Green</li>
<li>framebuffer[101][100] = (0, 255, 0, 255) ← Green</li>
<li>framebuffer[102][100] = (0, 255, 0, 255) ← Green</li>
<li>... 29,997 more green pixels</li>
</ul>
<ul>
<li>Step 5: Display Engine</li>
<li>Scans framebuffer at 60 Hz</li>
<li>Sends all 2,073,600 pixels to monitor via HDMI</li>
<li>Monitor displays the green rectangle</li>
<li>```</li>
</ul>
<ul>
<li><b>You give high-level commands (rectangle vertices).</b></li>
<li><b>GPU fills in all the pixels automatically.</b></li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## Step 4: The Operating System's Role (Window Manager)</li>
</ul>
<ul>
<li>You asked: "How does the OS handle multiple windows and track mouse clicks?"</li>
</ul>
<ul>
<li>### The Window Manager (OS Component)</li>
</ul>
<ul>
<li>On Linux: X11, Wayland</li>
<li>On Windows: Desktop Window Manager (DWM)</li>
<li>On macOS: Quartz Compositor</li>
</ul>
<ul>
<li><b>The window manager is a program that:</b></li>
<li>1. Maintains a list of all application windows</li>
<li>2. Decides where each window is positioned on screen</li>
<li>3. Composites (combines) all windows into ONE final framebuffer</li>
<li>4. Routes input events (mouse, keyboard) to the correct application</li>
</ul>
<ul>
<li>### Example: Two Applications Running</li>
</ul>
<ul>
<li>```</li>
<li><a class="el" href="classApplication.html" title="Main application orchestrating the simulation, rendering, and UI.">Application</a> A: Web browser window at (0, 0), size 800×600</li>
<li><a class="el" href="classApplication.html" title="Main application orchestrating the simulation, rendering, and UI.">Application</a> B: Our AeroDynControlRig at (400, 200), size 1200×800</li>
</ul>
<ul>
<li>Each application has its OWN framebuffer (off-screen):</li>
<li>Browser framebuffer: 800×600 pixels</li>
<li>Our app framebuffer: 1200×800 pixels</li>
</ul>
<ul>
<li>Window Manager (compositor):</li>
<li>1. Reads browser framebuffer (800×600)</li>
<li>2. Reads our app framebuffer (1200×800)</li>
<li>3. Composites them into FINAL framebuffer (1920×1080):</li>
</ul>
<ul>
<li>Final framebuffer:</li>
<li>Copy browser pixels to region (0, 0) → (800, 600)</li>
<li>Copy our app pixels to region (400, 200) → (1600, 1000)</li>
<li>Fill rest with desktop background</li>
</ul>
<ul>
<li>4. Display engine sends FINAL framebuffer to monitor</li>
<li>```</li>
</ul>
<ul>
<li><b>Each application renders to its OWN off-screen framebuffer.</b></li>
<li><b>Window manager combines them into the final screen framebuffer.</b></li>
</ul>
<ul>
<li>### How Our <a class="el" href="classApplication.html" title="Main application orchestrating the simulation, rendering, and UI.">Application</a> Works (Off-Screen Rendering)</li>
</ul>
<ul>
<li><b>File</b>: <code><a class="el" href="application_8cpp.html">src/app/application.cpp</a></code></li>
</ul>
<ul>
<li>```cpp</li>
<li>void <a class="el" href="classApplication.html#ae92abde0eb4b95fd7503308a13ed8c96" title="Initialize the application subsystems.">Application::init()</a> {</li>
<li>// Create our OWN framebuffer (off-screen, not the screen!)</li>
<li>glGenFramebuffers(1, &amp;fbo);</li>
<li>glBindFramebuffer(GL_FRAMEBUFFER, fbo);</li>
</ul>
<ul>
<li>// Create texture to hold rendered image (1200×800)</li>
<li>glGenTextures(1, &amp;fboTexture);</li>
<li>glBindTexture(GL_TEXTURE_2D, fboTexture);</li>
<li>glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 1200, 800, ...);</li>
</ul>
<ul>
<li>// Attach texture to framebuffer</li>
<li>glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, fboTexture, 0);</li>
<li>}</li>
</ul>
<ul>
<li>void <a class="el" href="classApplication.html#a4e7a520d659593b385b246a43e604dfb" title="Render the 3D scene (cube + axes)">Application::render3D()</a> {</li>
<li>// Render to OUR framebuffer (not screen!)</li>
<li>glBindFramebuffer(GL_FRAMEBUFFER, fbo);</li>
<li>glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</li>
</ul>
<ul>
<li>// Draw 3D cube</li>
<li>renderer.draw(state);</li>
<li>// GPU writes pixels to OUR framebuffer texture (1200×800)</li>
</ul>
<ul>
<li>// Unbind (go back to screen framebuffer)</li>
<li>glBindFramebuffer(GL_FRAMEBUFFER, 0);</li>
<li>}</li>
</ul>
<ul>
<li>void Application::renderUI() {</li>
<li>// Now render to SCREEN framebuffer (managed by GLFW/OS)</li>
<li>ImGui::Begin("Viewport");</li>
<li>ImGui::Image((void*)(intptr_t)fboTexture, ImVec2(1200, 800));</li>
<li>// This displays our off-screen framebuffer as a texture in the UI</li>
<li>ImGui::End();</li>
</ul>
<ul>
<li>// Render ImGui panels</li>
<li>for (auto&amp; panel : panels) {</li>
<li>panel-&gt;draw(state, camera);</li>
<li>}</li>
</ul>
<ul>
<li>// ImGui generates geometry, GPU writes to screen framebuffer</li>
<li>ImGui::Render();</li>
<li>ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());</li>
<li>}</li>
</ul>
<ul>
<li>void <a class="el" href="classApplication.html#af44c742342adf5305e430ff293f147c1" title="Execute one frame: update simulation, render 3D, render UI.">Application::tick()</a> {</li>
<li>render3D(); // → Our off-screen framebuffer</li>
<li>renderUI(); // → Screen framebuffer (shown in OS window)</li>
</ul>
<ul>
<li>glfwSwapBuffers(window);</li>
<li>// OS window manager reads our window's framebuffer</li>
<li>// Composites it with other windows</li>
<li>// Sends final result to monitor</li>
<li>}</li>
<li>```</li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## Step 5: Mouse Click Tracking (OS + <a class="el" href="classApplication.html" title="Main application orchestrating the simulation, rendering, and UI.">Application</a>)</li>
</ul>
<ul>
<li>### Who Tracks Mouse Position?</li>
</ul>
<ul>
<li><b>Hardware → OS Kernel → Window Manager → <a class="el" href="classApplication.html" title="Main application orchestrating the simulation, rendering, and UI.">Application</a></b></li>
</ul>
<ul>
<li>```</li>
<li>1. Mouse Hardware (USB device)</li>
<li>Sends: "I moved +5 pixels right, +3 pixels down"</li>
</ul>
<ul>
<li>2. OS Kernel (USB driver)</li>
<li>Maintains global cursor position:</li>
<li>cursor_x = 734</li>
<li>cursor_y = 412</li>
<li>Updates: cursor_x += 5, cursor_y += 3</li>
<li>New position: (739, 415)</li>
</ul>
<ul>
<li>3. Window Manager (compositor)</li>
<li>Knows all window positions:</li>
<li>Browser window: (0, 0) → (800, 600)</li>
<li>Our app window: (400, 200) → (1600, 1000)</li>
</ul>
<ul>
<li>Cursor is at (739, 415) globally.</li>
</ul>
<ul>
<li>Which window is that in?</li>
<li>739 is between 400 and 1600 ✓</li>
<li>415 is between 200 and 1000 ✓</li>
<li>→ Cursor is in our app window!</li>
</ul>
<ul>
<li>Convert to window-local coordinates:</li>
<li>local_x = 739 - 400 = 339</li>
<li>local_y = 415 - 200 = 215</li>
</ul>
<ul>
<li>If mouse is clicked:</li>
<li>Send event to our app: "Mouse clicked at (339, 215)"</li>
</ul>
<ul>
<li>4. Our <a class="el" href="classApplication.html" title="Main application orchestrating the simulation, rendering, and UI.">Application</a> (receives event via GLFW)</li>
<li>void Application::mouseCallback(GLFWwindow* window, int button, int action, int mods) {</li>
<li>double xpos, ypos;</li>
<li>glfwGetCursorPos(window, &amp;xpos, &amp;ypos);</li>
<li>// xpos = 339, ypos = 215 (window-local coordinates)</li>
</ul>
<ul>
<li>// ImGui checks if click is on a button</li>
<li>ImGuiIO&amp; io = ImGui::GetIO();</li>
<li>io.MousePos = ImVec2(xpos, ypos);</li>
</ul>
<ul>
<li>if (ImGui::IsMouseClicked(0)) {</li>
<li>// ImGui internally checks: is cursor over a button?</li>
<li>// Button bounds: (50, 200) → (150, 230)</li>
<li>// Cursor: (339, 215) → NOT in button</li>
<li>}</li>
<li>}</li>
<li>```</li>
</ul>
<ul>
<li>### Where is Mouse Position Stored?</li>
</ul>
<ul>
<li>- <b>Kernel</b>: Global screen coordinates (updated by USB driver)</li>
<li>- <b>Window Manager</b>: Global coordinates + window hit testing</li>
<li>- <b><a class="el" href="classApplication.html" title="Main application orchestrating the simulation, rendering, and UI.">Application</a> (GLFW)</b>: Window-local coordinates</li>
<li>- <b>ImGui</b>: Application-local coordinates + UI element hit testing</li>
</ul>
<ul>
<li><b>NOT in VRAM!</b> Mouse position is in <b>system RAM</b> (kernel memory, application memory).</li>
</ul>
<ul>
<li>### Visual Cursor</li>
</ul>
<ul>
<li>The cursor image (arrow) is drawn by the <b>window manager</b>:</li>
</ul>
<ul>
<li>```</li>
<li>Window Manager's compositor loop (60 Hz):</li>
<li>1. Composite all application windows → final framebuffer</li>
<li>2. Draw cursor image at (cursor_x, cursor_y) ON TOP</li>
<li>cursor_pixels = load_image("arrow.png")</li>
<li>for each pixel in cursor_pixels:</li>
<li>framebuffer[cursor_x + offset_x][cursor_y + offset_y] = cursor_pixel</li>
<li>3. Send framebuffer to display engine → monitor</li>
<li>```</li>
</ul>
<ul>
<li>That's why the cursor is <b>always on top</b> of everything!</li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## Step 6: Multi-Monitor Support</li>
</ul>
<ul>
<li>### One Framebuffer Per Monitor</li>
</ul>
<ul>
<li>```</li>
<li>System with 2 monitors:</li>
<li>Monitor 1: 1920×1080 @ (0, 0)</li>
<li>Monitor 2: 1920×1080 @ (1920, 0) ← To the right of monitor 1</li>
</ul>
<ul>
<li>Two framebuffers in RAM:</li>
<li>Framebuffer 1: 1920×1080 × 4 bytes = 8 MB</li>
<li>Framebuffer 2: 1920×1080 × 4 bytes = 8 MB</li>
</ul>
<ul>
<li>Window Manager:</li>
<li>Window A is at global position (500, 100) → on Monitor 1</li>
<li>Window B is at global position (2200, 300) → on Monitor 2</li>
</ul>
<ul>
<li>Composite Window A into Framebuffer 1</li>
<li>Composite Window B into Framebuffer 2</li>
</ul>
<ul>
<li>Display Engine:</li>
<li>Send Framebuffer 1 to Monitor 1 via HDMI port 1</li>
<li>Send Framebuffer 2 to Monitor 2 via HDMI port 2</li>
<li>```</li>
</ul>
<ul>
<li><b>Each monitor has its own framebuffer.</b></li>
<li><b>Window manager decides which window goes to which framebuffer.</b></li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## Summary: The Complete Flow</li>
</ul>
<ul>
<li>```</li>
<li>┌─────────────────────────────────────────────────────────────┐</li>
<li>│ YOUR APPLICATION │</li>
<li>│ "Draw a green rectangle from (100,100) to (300,250)" │</li>
<li>│ │</li>
<li>│ Code: │</li>
<li>│ float vertices[] = { ... }; ← YOU create geometry │</li>
<li>│ glBufferData(..., vertices); ← Upload to GPU │</li>
<li>│ glDrawArrays(...); ← Tell GPU to draw │</li>
<li>└───────────────────────┬─────────────────────────────────────┘</li>
<li>│</li>
<li>▼</li>
<li>┌─────────────────────────────────────────────────────────────┐</li>
<li>│ GPU (EXECUTION UNITS) │</li>
<li>│ 1. Vertex Shader: Process 6 vertices (2 triangles) │</li>
<li>│ 2. Rasterizer: Find 30,000 pixels inside triangles │</li>
<li>│ 3. Fragment Shader: Run 30,000 times, output green │</li>
<li>│ 4. Write to YOUR app's framebuffer: │</li>
<li>│ framebuffer[100][100] = (0, 255, 0, 255) │</li>
<li>│ framebuffer[101][100] = (0, 255, 0, 255) │</li>
<li>│ ... 29,998 more pixels │</li>
<li>└───────────────────────┬─────────────────────────────────────┘</li>
<li>│</li>
<li>▼</li>
<li>┌─────────────────────────────────────────────────────────────┐</li>
<li>│ APPLICATION FRAMEBUFFER (in RAM) │</li>
<li>│ 1200×800 texture with your rendered content │</li>
<li>│ [Contains 3D cube + UI panels] │</li>
<li>└───────────────────────┬─────────────────────────────────────┘</li>
<li>│</li>
<li>▼</li>
<li>┌─────────────────────────────────────────────────────────────┐</li>
<li>│ WINDOW MANAGER (OS Compositor) │</li>
<li>│ 1. Read your app's framebuffer │</li>
<li>│ 2. Read other apps' framebuffers │</li>
<li>│ 3. Composite into SCREEN framebuffer (1920×1080): │</li>
<li>│ - Browser window at (0, 0) │</li>
<li>│ - Your app window at (400, 200) │</li>
<li>│ - Desktop background │</li>
<li>│ - Mouse cursor at (cursor_x, cursor_y) │</li>
<li>└───────────────────────┬─────────────────────────────────────┘</li>
<li>│</li>
<li>▼</li>
<li>┌─────────────────────────────────────────────────────────────┐</li>
<li>│ SCREEN FRAMEBUFFER (in RAM) │</li>
<li>│ 1920×1080 × 4 bytes = 8 MB │</li>
<li>│ [Final composited image with all windows + cursor] │</li>
<li>└───────────────────────┬─────────────────────────────────────┘</li>
<li>│</li>
<li>▼</li>
<li>┌─────────────────────────────────────────────────────────────┐</li>
<li>│ DISPLAY ENGINE (on CPU die) │</li>
<li>│ Reads screen framebuffer at 60 Hz │</li>
<li>│ Sends 2,073,600 pixel values via HDMI/DisplayPort │</li>
<li>└───────────────────────┬─────────────────────────────────────┘</li>
<li>│ HDMI cable</li>
<li>▼</li>
<li>┌─────────────────────────────────────────────────────────────┐</li>
<li>│ MONITOR (Dumb Display) │</li>
<li>│ Receives pixel stream, lights up LEDs/LCD │</li>
<li>│ Has NO memory, NO logic, just displays what it receives │</li>
<li>└─────────────────────────────────────────────────────────────┘</li>
<li>```</li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## Key Insights (Answers to Your Questions)</li>
</ul>
<ul>
<li>### 1. "How to put a pixel on a monitor?"</li>
</ul>
<ul>
<li>You DON'T write individual pixel values. Instead:</li>
<li>- <b>You</b>: Create geometry (vertices of triangles)</li>
<li>- <b>GPU</b>: Rasterizes (figures out which pixels are inside)</li>
<li>- <b>Fragment Shader</b>: Runs for each pixel, outputs color</li>
<li>- <b>GPU</b>: Writes color to framebuffer</li>
<li>- <b>Display Engine</b>: Sends framebuffer to monitor</li>
</ul>
<ul>
<li>### 2. "Who is making the framebuffer pixel by pixel?"</li>
</ul>
<ul>
<li><b>The GPU's fragment shader</b> runs millions of times (once per pixel) and writes to the framebuffer.</li>
</ul>
<ul>
<li>You write the shader logic, GPU executes it in parallel.</li>
</ul>
<ul>
<li>### 3. "Does the application have to give each pixel value?"</li>
</ul>
<ul>
<li><b>NO!</b> You give:</li>
<li>- Geometry (triangle vertices)</li>
<li>- Shader logic (how to color pixels)</li>
</ul>
<ul>
<li>GPU fills in all the pixels automatically.</li>
</ul>
<ul>
<li>### 4. "Is the OS in VRAM?"</li>
</ul>
<ul>
<li><b>NO!</b> The window manager runs on the <b>CPU</b> using <b>system RAM</b>.</li>
</ul>
<ul>
<li>VRAM (or GPU memory region) only stores:</li>
<li>- Vertex buffers (geometry)</li>
<li>- Textures (images)</li>
<li>- Framebuffers (pixel arrays)</li>
</ul>
<ul>
<li>### 5. "Does VRAM have a 2D canvas per monitor?"</li>
</ul>
<ul>
<li><b>YES!</b> Each monitor has a framebuffer (2D pixel array) in RAM.</li>
</ul>
<ul>
<li>For integrated GPU: in system RAM.</li>
<li>For discrete GPU: in VRAM.</li>
</ul>
<ul>
<li>### 6. "Who tracks mouse position?"</li>
</ul>
<ul>
<li>- <b>Kernel</b>: Global screen coordinates (all monitors)</li>
<li>- <b>Window Manager</b>: Determines which window is under cursor</li>
<li>- <b><a class="el" href="classApplication.html" title="Main application orchestrating the simulation, rendering, and UI.">Application</a></b>: Receives window-local coordinates</li>
<li>- <b>ImGui</b>: Checks if cursor is over a UI element</li>
</ul>
<ul>
<li>NOT stored in VRAM - stored in system RAM (kernel + application memory).</li>
</ul>
<ul>
<li>### 7. "Is it like JSON API for web?"</li>
</ul>
<ul>
<li><b>Exactly!</b> You write high-level commands:</li>
<li>``&lsquo;cpp</li>
<li>// Like HTTP request: "POST /api/rectangle {x:100, y:100, color:'green&amp;rsquo;}"</li>
<li>glDrawArrays(GL_TRIANGLES, 0, 6); // "GPU, draw these triangles"</li>
<li>```</li>
</ul>
<ul>
<li>GPU driver translates to low-level GPU machine code.</li>
<li>GPU executes and fills pixels.</li>
</ul>
<ul>
<li>### 8. "Monitor is just a dumb display?"</li>
</ul>
<ul>
<li><b>YES!</b> Monitor receives a pixel stream 60 times per second.</li>
<li>It has no idea what application created it.</li>
<li>It just lights up pixels as told.</li>
</ul>
<ul>
<li>### 9. "Something tracks applications, windows, screens?"</li>
</ul>
<ul>
<li><b>The Window Manager</b> (OS component):</li>
<li>- X11, Wayland (Linux)</li>
<li>- Desktop Window Manager (Windows)</li>
<li>- Quartz Compositor (macOS)</li>
</ul>
<ul>
<li>Runs on CPU, uses system RAM, composites all windows into final framebuffer.</li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## See Also</li>
</ul>
<ul>
<li>- <a class="el" href="hardware_pipeline.html">Hardware Pipeline: RAM → CPU → GPU → Screen</a> - Complete RAM → GPU → Screen flow</li>
<li>- <a class="el" href="opengl_tutorial.html">OpenGL Deep Dive Tutorial</a> - OpenGL concepts (VBO, VAO, FBO)</li>
<li>- <a class="el" href="opengl_imgui_integration.html">OpenGL + ImGui Integration</a> - Off-screen rendering technique</li>
<li>- <a class="el" href="architecture.html">Complete System Architecture</a> - <a class="el" href="classApplication.html" title="Main application orchestrating the simulation, rendering, and UI.">Application</a> architecture overview */ </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
