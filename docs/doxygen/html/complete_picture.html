<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AeroDynControlRig: The Complete Picture: From Your Intent to Pixels on Screen</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AeroDynControlRig
   </div>
   <div id="projectbrief">Flight control algorithm testbed with OpenGL 3D visualization and ImGui dashboard</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('complete_picture.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">The Complete Picture: From Your Intent to Pixels on Screen </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li></li>
<li></li>
</ul>
<ul>
<li>## The Big Picture: What You Want vs What Actually Happens</li>
</ul>
<ul>
<li>### What You Think (High-Level Intent)</li>
</ul>
<ul>
<li>```</li>
<li>"I want to create a window with resizable, dockable panels</li>
<li>that show telemetry data with nice fonts and respond to</li>
<li>mouse clicks and drags."</li>
<li>```</li>
</ul>
<ul>
<li>### What Actually Happens (3 Translation Layers)</li>
</ul>
<ul>
<li><div class="dotgraph">
<div class="caption">
The Three Translation Layers</div>
</div>
</li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## Layer 0: Your Code (Human Intent)</li>
</ul>
<ul>
<li><b>What you write</b> (<code><a class="el" href="telemetry__panel_8cpp.html">src/gui/panels/telemetry_panel.cpp</a></code>):</li>
</ul>
<ul>
<li>```cpp</li>
<li>void <a class="el" href="classTelemetryPanel.html#abe2679f505e98b764eb45e0d78d6049a" title="Render the panel&#39;s ImGui interface.">TelemetryPanel::draw(SimulationState&amp; state, Camera&amp; camera)</a> {</li>
<li>// YOUR INTENT: "Show a window with telemetry data"</li>
<li>ImGui::Begin("Telemetry");</li>
</ul>
<ul>
<li>// YOUR INTENT: "Display quaternion values in a nice format"</li>
<li>ImGui::Text("Quaternion: %.3f, %.3f, %.3f, %.3f",</li>
<li>state.quaternion.w, state.quaternion.x,</li>
<li>state.quaternion.y, state.quaternion.z);</li>
</ul>
<ul>
<li>// YOUR INTENT: "Button that does something when clicked"</li>
<li>if (ImGui::Button("Reset")) {</li>
<li>state.quaternion = {1.0, 0.0, 0.0, 0.0};</li>
<li>}</li>
</ul>
<ul>
<li>ImGui::End();</li>
<li>}</li>
<li>```</li>
</ul>
<ul>
<li><b>What you're saying:</b></li>
<li>- "Make a window titled 'Telemetry'"</li>
<li>- "Show some text with these values"</li>
<li>- "Make a button, tell me if it's clicked"</li>
</ul>
<ul>
<li><b>You DON'T specify:</b></li>
<li>- Where each pixel goes</li>
<li>- What triangles to draw</li>
<li>- How to detect mouse clicks on the button</li>
<li>- What color each pixel should be</li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## Layer 1: ImGui (Intent → Geometry)</li>
</ul>
<ul>
<li><b>ImGui's job:</b> Convert your high-level intent into <b>geometry</b> (triangles, vertices, colors).</li>
</ul>
<ul>
<li><div class="dotgraph">
<div class="caption">
ImGui Translation</div>
</div>
</li>
</ul>
<ul>
<li>### ImGui Generates Vertices</li>
</ul>
<ul>
<li><b>For the window background:</b></li>
<li>```cpp</li>
<li>// ImGui internally creates:</li>
<li>ImDrawVert vertices[4] = {</li>
<li>{pos: {10, 10}, uv: {0,0}, col: 0xF0000000}, // Top-left</li>
<li>{pos: {210, 10}, uv: {1,0}, col: 0xF0000000}, // Top-right</li>
<li>{pos: {210, 410}, uv: {1,1}, col: 0xF0000000}, // Bottom-right</li>
<li>{pos: {10, 410}, uv: {0,1}, col: 0xF0000000}, // Bottom-left</li>
<li>};</li>
<li>ImDrawIdx indices[6] = {0, 1, 2, 0, 2, 3}; // 2 triangles</li>
<li>```</li>
</ul>
<ul>
<li><b>For the text "Quaternion: 1.000, 0.000, 0.000, 0.000":</b></li>
<li>```cpp</li>
<li>// Each character = 1 quad = 2 triangles = 6 vertices</li>
<li>// 30 characters × 6 vertices = 180 vertices</li>
<li>ImDrawVert text_vertices[180];</li>
<li>// Each vertex has:</li>
<li>// - Position: where on screen</li>
<li>// - UV: which part of font texture to sample</li>
<li>// - Color: text color</li>
<li>```</li>
</ul>
<ul>
<li><b>For mouse click detection:</b></li>
<li>```cpp</li>
<li>// ImGui checks:</li>
<li>ImVec2 mouse_pos = ImGui::GetMousePos(); // e.g., (125, 350)</li>
<li>ImVec2 button_min = {100, 340};</li>
<li>ImVec2 button_max = {200, 370};</li>
</ul>
<ul>
<li>if (mouse_pos.x &gt;= button_min.x &amp;&amp; mouse_pos.x &lt;= button_max.x &amp;&amp;</li>
<li>mouse_pos.y &gt;= button_min.y &amp;&amp; mouse_pos.y &lt;= button_max.y &amp;&amp;</li>
<li>ImGui::IsMouseClicked(0)) {</li>
<li>return true; // Button was clicked!</li>
<li>}</li>
<li>```</li>
</ul>
<ul>
<li>### ImGui's Output</li>
</ul>
<ul>
<li><b>ImGui produces a DrawList:</b></li>
<li>```</li>
<li>ImDrawData {</li>
<li>total_vertices: 274 (window + title + text + button + button text)</li>
<li>total_indices: 822 (274 vertices / 3 = 91 triangles × 3 = 273... rounded)</li>
</ul>
<ul>
<li>DrawList 0: {</li>
<li>VtxBuffer: [vertex0, vertex1, ..., vertex273]</li>
<li>IdxBuffer: [0, 1, 2, 3, 4, 5, ..., 820, 821]</li>
<li>CmdBuffer: [</li>
<li>{texture: font_atlas, idx_count: 822, clip_rect: (0,0,1920,1080)}</li>
<li>]</li>
<li>}</li>
<li>}</li>
<li>```</li>
</ul>
<ul>
<li><b>This is still CPU-side data!</b> Just an array of vertices and indices.</li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## Layer 2: OpenGL (Geometry → GPU Commands)</li>
</ul>
<ul>
<li><b>OpenGL's job:</b> Translate ImGui's geometry into <b>GPU commands</b> (VBO, VAO, draw calls).</li>
</ul>
<ul>
<li><div class="dotgraph">
<div class="caption">
OpenGL Translation</div>
</div>
</li>
</ul>
<ul>
<li>### OpenGL Backend Code</li>
</ul>
<ul>
<li><b>File:</b> <code>external/imgui/backends/imgui_impl_opengl3.cpp</code></li>
</ul>
<ul>
<li>```cpp</li>
<li>void ImGui_ImplOpenGL3_RenderDrawData(ImDrawData* draw_data) {</li>
<li>for (int n = 0; n &lt; draw_data-&gt;CmdListsCount; n++) {</li>
<li>const ImDrawList* cmd_list = draw_data-&gt;CmdLists[n];</li>
</ul>
<ul>
<li>// STEP 1: Upload vertices to GPU (VBO)</li>
<li>glBindBuffer(GL_ARRAY_BUFFER, g_VboHandle);</li>
<li>glBufferData(GL_ARRAY_BUFFER,</li>
<li>cmd_list-&gt;VtxBuffer.Size * sizeof(ImDrawVert),</li>
<li>cmd_list-&gt;VtxBuffer.Data, // ImGui's vertex array</li>
<li>GL_STREAM_DRAW); // Changes every frame</li>
</ul>
<ul>
<li>// STEP 2: Upload indices to GPU (EBO)</li>
<li>glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_ElementsHandle);</li>
<li>glBufferData(GL_ELEMENT_ARRAY_BUFFER,</li>
<li>cmd_list-&gt;IdxBuffer.Size * sizeof(ImDrawIdx),</li>
<li>cmd_list-&gt;IdxBuffer.Data, // ImGui's index array</li>
<li>GL_STREAM_DRAW);</li>
</ul>
<ul>
<li>// STEP 3: Describe format (VAO - already set up once)</li>
<li>// Position: 2 floats at offset 0</li>
<li>// UV: 2 floats at offset 8</li>
<li>// Color: 4 bytes at offset 16</li>
</ul>
<ul>
<li>// STEP 4: Issue draw command</li>
<li>for (int cmd_i = 0; cmd_i &lt; cmd_list-&gt;CmdBuffer.Size; cmd_i++) {</li>
<li>const ImDrawCmd* pcmd = &amp;cmd_list-&gt;CmdBuffer[cmd_i];</li>
</ul>
<ul>
<li>glBindTexture(GL_TEXTURE_2D, pcmd-&gt;TextureId); // Font atlas</li>
<li>glDrawElements(GL_TRIANGLES,</li>
<li>pcmd-&gt;ElemCount, // 822 indices</li>
<li>GL_UNSIGNED_SHORT,</li>
<li>(void*)(intptr_t)(pcmd-&gt;IdxOffset * sizeof(ImDrawIdx)));</li>
<li>}</li>
<li>}</li>
<li>}</li>
<li>```</li>
</ul>
<ul>
<li>### What OpenGL Actually Does</li>
</ul>
<ul>
<li><b>VBO (Vertex Buffer Object):</b></li>
<li>- Allocates GPU memory (system RAM for integrated GPU)</li>
<li>- Copies vertex data from CPU to GPU memory region</li>
<li>- Just storage, like copying a file to a USB drive</li>
</ul>
<ul>
<li><b>EBO (Element Buffer Object):</b></li>
<li>- Stores index data (which vertices form triangles)</li>
<li>- <code>indices = [0, 1, 2]</code> means "triangle from vertex 0, 1, 2"</li>
</ul>
<ul>
<li><b>VAO (Vertex Array Object):</b></li>
<li>- Describes the format: "First 8 bytes = position, next 8 = UV, next 4 = color"</li>
<li>- Like a struct definition for the vertex data</li>
</ul>
<ul>
<li><b>glDrawElements():</b></li>
<li>- Sends command to GPU: "Draw triangles using VBO/EBO/VAO"</li>
<li>- This is the actual rendering command!</li>
</ul>
<ul>
<li>### The "JSON-like File" You Mentioned</li>
</ul>
<ul>
<li><b>You're exactly right!</b> OpenGL creates a command structure:</li>
</ul>
<ul>
<li>```json</li>
<li>{</li>
<li>"command": "DRAW_INDEXED_TRIANGLES",</li>
<li>"vertex_buffer": {</li>
<li>"id": 42,</li>
<li>"format": {</li>
<li>"position": {"type": "float", "count": 2, "offset": 0},</li>
<li>"uv": {"type": "float", "count": 2, "offset": 8},</li>
<li>"color": {"type": "ubyte", "count": 4, "offset": 16}</li>
<li>},</li>
<li>"data": [</li>
<li>{"position": [10, 10], "uv": [0, 0], "color": [240, 0, 0, 0]},</li>
<li>{"position": [210, 10], "uv": [1, 0], "color": [240, 0, 0, 0]},</li>
<li>...</li>
<li>]</li>
<li>},</li>
<li>"index_buffer": {</li>
<li>"id": 17,</li>
<li>"data": [0, 1, 2, 0, 2, 3, ...]</li>
<li>},</li>
<li>"texture": {"id": 5, "type": "font_atlas"},</li>
<li>"shader": {"id": 3, "type": "imgui_shader"},</li>
<li>"count": 822</li>
<li>}</li>
<li>```</li>
</ul>
<ul>
<li><b>GPU driver reads this "JSON" and executes it.</b></li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## Layer 3: GPU (Commands → Pixels)</li>
</ul>
<ul>
<li><b>GPU's job:</b> Execute OpenGL commands and <b>fill framebuffer with RGBA values</b>.</li>
</ul>
<ul>
<li><div class="dotgraph">
<div class="caption">
GPU Execution</div>
</div>
</li>
</ul>
<ul>
<li>### GPU Pipeline Steps</li>
</ul>
<ul>
<li><b>Step 1: Vertex Shader</b> (runs 274 times, once per vertex)</li>
</ul>
<ul>
<li>```glsl</li>
<li>// ImGui's vertex shader</li>
<li>layout (location = 0) in vec2 Position;</li>
<li>layout (location = 1) in vec2 UV;</li>
<li>layout (location = 2) in vec4 Color;</li>
</ul>
<ul>
<li>uniform mat4 ProjMtx; // Orthographic projection</li>
</ul>
<ul>
<li>out vec2 Frag_UV;</li>
<li>out vec4 Frag_Color;</li>
</ul>
<ul>
<li>void <a class="el" href="main_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a> {</li>
<li>// <a class="el" href="classTransform.html">Transform</a> position to screen space</li>
<li>gl_Position = ProjMtx * vec4(Position.xy, 0, 1);</li>
<li>Frag_UV = UV;</li>
<li>Frag_Color = Color;</li>
<li>}</li>
<li>```</li>
</ul>
<ul>
<li><b>What happens:</b></li>
<li>- Vertex 0: position (10, 10) → screen position</li>
<li>- Vertex 1: position (210, 10) → screen position</li>
<li>- ... 272 more vertices</li>
</ul>
<ul>
<li><b>Step 2: Rasterizer</b> (GPU hardware)</li>
</ul>
<ul>
<li>```</li>
<li>For each of 274 triangles:</li>
<li>- Find ALL pixels inside the triangle</li>
<li>- Interpolate UV and Color for each pixel</li>
</ul>
<ul>
<li>Example triangle: vertices at (10, 10), (210, 10), (210, 410)</li>
<li>→ Covers ~40,000 pixels</li>
</ul>
<ul>
<li>Output: List of 50,000 pixels to process</li>
<li>```</li>
</ul>
<ul>
<li><b>Step 3: Fragment Shader</b> (runs 50,000 times, once per pixel)</li>
</ul>
<ul>
<li>```glsl</li>
<li>// ImGui's fragment shader</li>
<li>in vec2 Frag_UV;</li>
<li>in vec4 Frag_Color;</li>
</ul>
<ul>
<li>uniform sampler2D Texture; // Font atlas</li>
</ul>
<ul>
<li>out vec4 Out_Color;</li>
</ul>
<ul>
<li>void <a class="el" href="main_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a> {</li>
<li>// Sample texture at UV coordinate</li>
<li>vec4 tex_color = texture(Texture, Frag_UV.st);</li>
</ul>
<ul>
<li>// Multiply by vertex color</li>
<li>Out_Color = Frag_Color * tex_color;</li>
</ul>
<ul>
<li>// GPU writes this to framebuffer[pixel_x][pixel_y]</li>
<li>}</li>
<li>```</li>
</ul>
<ul>
<li><b>What happens:</b></li>
<li>- Pixel at (125, 350): Sample texture, output RGBA → framebuffer[350][125]</li>
<li>- Pixel at (126, 350): Sample texture, output RGBA → framebuffer[350][126]</li>
<li>- ... 49,998 more pixels</li>
</ul>
<ul>
<li>### Result: Framebuffer Filled</li>
</ul>
<ul>
<li>```</li>
<li>framebuffer[10][10] = {240, 0, 0, 0} ← Window background</li>
<li>framebuffer[11][10] = {240, 0, 0, 0} ← Window background</li>
<li>...</li>
<li>framebuffer[30][15] = {255, 255, 255, 255} ← Letter 'T' in "Telemetry"</li>
<li>framebuffer[31][15] = {255, 255, 255, 255} ← Letter 'T'</li>
<li>...</li>
<li>framebuffer[125][350] = {100, 150, 255, 255} ← Button background</li>
<li>...</li>
<li>```</li>
</ul>
<ul>
<li><b>Now the framebuffer has pixel colors!</b></li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## Layer 4: Display Engine → Monitor</li>
</ul>
<ul>
<li><div class="dotgraph">
<div class="caption">
Display Path</div>
</div>
</li>
</ul>
<ul>
<li><b>Every 16.67ms (60 Hz):</b></li>
<li>1. Display engine reads entire framebuffer (2,073,600 pixels)</li>
<li>2. Converts to HDMI signal</li>
<li>3. Sends to monitor</li>
<li>4. Monitor updates physical pixels</li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## The Complete Flow (All Layers)</li>
</ul>
<ul>
<li><div class="dotgraph">
<div class="caption">
Complete System Flow</div>
</div>
</li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## Summary: Your Understanding is Correct!</li>
</ul>
<ul>
<li>### You Said:</li>
</ul>
<ul>
<li>&gt; "We need to tell the OS we are going to render some data.</li>
<li>&gt; That data is going to have a main window with transparent background</li>
<li>&gt; and resizable, dockable panels with mouse events."</li>
</ul>
<ul>
<li><b>✓ CORRECT!</b> This is handled by:</li>
<li>- <b>GLFW</b>: Creates the OS window</li>
<li>- <b>ImGui</b>: Handles panels, docking, mouse events, layout</li>
</ul>
<ul>
<li>### You Said:</li>
</ul>
<ul>
<li>&gt; "Now we need to convert all this to actual pixels the monitor can see.</li>
<li>&gt; ImGui gives panels and mouse events and makes it easy,</li>
<li>&gt; but it's not OS/hardware/GPU compatible yet."</li>
</ul>
<ul>
<li><b>✓ CORRECT!</b> ImGui produces geometry (vertex arrays), not pixels.</li>
</ul>
<ul>
<li>### You Said:</li>
</ul>
<ul>
<li>&gt; "Then OpenGL comes and VAO, VBO, and creates one big JSON-like file.
 * &gt; GPU parses vertex/color and creates the canvas to send to HDMI."</li>
</ul>
<ul>
<li><b>✓ EXACTLY RIGHT!</b> OpenGL creates a command structure (like JSON),</li>
<li>GPU executes it and fills framebuffer, display engine sends to monitor.</li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## The Roles</li>
</ul>
<ul>
<li>| Component | Role | Analogy |</li>
<li>|--------&mdash;|---&mdash;|------&mdash;|</li>
<li>| <b>Your Code</b> | Express intent | Restaurant customer ordering |</li>
<li>| <b>ImGui</b> | Intent → Geometry | Waiter writing order |</li>
<li>| <b>OpenGL</b> | Geometry → GPU commands | Kitchen manager organizing |</li>
<li>| <b>GPU</b> | Commands → Pixels | Chefs cooking in parallel |</li>
<li>| <b>Framebuffer</b> | Store pixels | Serving platter |</li>
<li>| <b>Display Engine</b> | Pixels → Signal | Server delivering food |</li>
<li>| <b>Monitor</b> | Display pixels | Customer eating |</li>
</ul>
<ul>
<li><b>You never touch pixels directly. You express intent, libraries translate it down to hardware.</b></li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## See Also</li>
</ul>
<ul>
<li>- <a class="el" href="pixel_truth.html">The Pixel Truth: Everything is Just Computing RGBA</a> - Everything is just computing RGBA</li>
<li>- <a class="el" href="display_fundamentals.html">Display Fundamentals: Pixels, Framebuffers, and the OS</a> - How pixels get to monitor</li>
<li>- <a class="el" href="hardware_pipeline.html">Hardware Pipeline: RAM → CPU → GPU → Screen</a> - CPU/GPU hardware details</li>
<li>- <a class="el" href="opengl_tutorial.html">OpenGL Deep Dive Tutorial</a> - OpenGL API deep dive</li>
<li>- <a class="el" href="imgui_tutorial.html">ImGui Deep Dive Tutorial</a> - ImGui API deep dive</li>
<li>- <a class="el" href="opengl_imgui_integration.html">OpenGL + ImGui Integration</a> - How they work together */ </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
