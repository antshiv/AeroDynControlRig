<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AeroDynControlRig: GPU Pipeline: From RAM to Screen</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AeroDynControlRig
   </div>
   <div id="projectbrief">Flight control algorithm testbed with OpenGL 3D visualization and ImGui dashboard</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('gpu_pipeline.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">GPU Pipeline: From RAM to Screen </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md81">Overview</a></li>
<li class="level1"><a href="#autotoc_md83">The Complete Pipeline</a></li>
<li class="level1"><a href="#autotoc_md85">Stage 1: CPU Side - Your C++ Code</a><ul><li class="level2"><a href="#autotoc_md86">1.1 Application Update Loop</a></li>
<li class="level2"><a href="#autotoc_md88">1.2 Module Updates (Pure CPU Work)</a></li>
<li class="level2"><a href="#autotoc_md90">1.3 ImGui Vertex Generation</a></li>
<li class="level2"><a href="#autotoc_md92">1.4 OpenGL Command Submission</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md94">Stage 2: PCIe Bus Transfer</a><ul><li class="level2"><a href="#autotoc_md95">2.1 CPU → GPU Communication</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md97">Stage 3: GPU Side - Graphics Card</a><ul><li class="level2"><a href="#autotoc_md98">3.1 GPU Architecture Overview</a></li>
<li class="level2"><a href="#autotoc_md100">3.2 GPU Memory Hierarchy</a></li>
<li class="level2"><a href="#autotoc_md102">3.3 Vertex Shader Execution</a></li>
<li class="level2"><a href="#autotoc_md104">3.4 Rasterization (Fixed-Function Hardware)</a></li>
<li class="level2"><a href="#autotoc_md106">3.5 Fragment Shader Execution</a></li>
<li class="level2"><a href="#autotoc_md108">3.6 Framebuffer Operations</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md110">Stage 4: Display Output</a><ul><li class="level2"><a href="#autotoc_md111">4.1 Swap Buffers</a></li>
<li class="level2"><a href="#autotoc_md113">4.2 Display Controller Scanout</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md115">Complete Frame Timing Breakdown</a></li>
<li class="level1"><a href="#autotoc_md117">Memory Bandwidth Analysis</a><ul><li class="level2"><a href="#autotoc_md118">CPU Side (System RAM)</a></li>
<li class="level2"><a href="#autotoc_md119">PCIe Bus (CPU ↔ GPU)</a></li>
<li class="level2"><a href="#autotoc_md120">GPU Side (VRAM)</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md122">Optimization Insights</a><ul><li class="level2"><a href="#autotoc_md123">Where Time Is Actually Spent</a></li>
<li class="level2"><a href="#autotoc_md124">If You Wanted to Optimize</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md126">Key Takeaways</a></li>
<li class="level1"><a href="#autotoc_md128">Mapping to AeroDynControlRig Code</a></li>
<li class="level1"><a href="#autotoc_md130">Related Documentation</a></li>
<li class="level1"><a href="#autotoc_md132">Further Reading</a></li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md_docs_gpu_pipeline"></a></p>
<h1><a class="anchor" id="autotoc_md81"></a>
Overview</h1>
<p>This document explains <b>exactly</b> how data flows from your C++ code in RAM through the CPU cache, across the PCIe bus to the GPU, through shader execution units, and finally to pixels on your screen.</p>
<p>Understanding this pipeline is critical for graphics programming because <b>you're working at the lowest level</b> - directly commanding the GPU hardware.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md83"></a>
The Complete Pipeline</h1>
<div class="fragment"><div class="line">┌─────────────────────────────────────────────────────────────────┐</div>
<div class="line">│ CPU Side (Your C++ Code)                                        │</div>
<div class="line">├─────────────────────────────────────────────────────────────────┤</div>
<div class="line">│                                                                 │</div>
<div class="line">│  Application (main.cpp)                                         │</div>
<div class="line">│       ↓                                                         │</div>
<div class="line">│  Update Modules (quaternion integration, etc.)                  │</div>
<div class="line">│       ↓                                                         │</div>
<div class="line">│  Write to SimulationState (RAM)                                 │</div>
<div class="line">│       ↓                                                         │</div>
<div class="line">│  Panels read SimulationState (CPU cache hit/miss)              │</div>
<div class="line">│       ↓                                                         │</div>
<div class="line">│  ImGui builds vertex data (RAM allocation)                      │</div>
<div class="line">│       ↓                                                         │</div>
<div class="line">│  OpenGL driver queues commands (RAM → kernel space)            │</div>
<div class="line">│       ↓                                                         │</div>
<div class="line">├─────────────────────────────────────────────────────────────────┤</div>
<div class="line">│ PCIe Bus Transfer (DMA)                                         │</div>
<div class="line">├─────────────────────────────────────────────────────────────────┤</div>
<div class="line">│       ↓                                                         │</div>
<div class="line">│  GPU receives command buffer                                    │</div>
<div class="line">│       ↓                                                         │</div>
<div class="line">├─────────────────────────────────────────────────────────────────┤</div>
<div class="line">│ GPU Side (Graphics Card)                                        │</div>
<div class="line">├─────────────────────────────────────────────────────────────────┤</div>
<div class="line">│                                                                 │</div>
<div class="line">│  GPU VRAM (vertex data, textures, framebuffers)                │</div>
<div class="line">│       ↓                                                         │</div>
<div class="line">│  Vertex Shader (parallel execution on shader cores)            │</div>
<div class="line">│       ↓                                                         │</div>
<div class="line">│  Rasterizer (hardware fixed-function)                          │</div>
<div class="line">│       ↓                                                         │</div>
<div class="line">│  Fragment Shader (parallel execution on shader cores)          │</div>
<div class="line">│       ↓                                                         │</div>
<div class="line">│  Framebuffer (VRAM)                                             │</div>
<div class="line">│       ↓                                                         │</div>
<div class="line">│  Display Controller scans framebuffer                           │</div>
<div class="line">│       ↓                                                         │</div>
<div class="line">│  HDMI/DisplayPort output                                        │</div>
<div class="line">│       ↓                                                         │</div>
<div class="line">│  Monitor pixels illuminate                                      │</div>
<div class="line">│                                                                 │</div>
<div class="line">└─────────────────────────────────────────────────────────────────┘</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md85"></a>
Stage 1: CPU Side - Your C++ Code</h1>
<h2><a class="anchor" id="autotoc_md86"></a>
1.1 Application Update Loop</h2>
<p>File: <code><a class="el" href="application_8cpp.html">src/app/application.cpp</a>:364-418</code></p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classApplication.html#af44c742342adf5305e430ff293f147c1">Application::tick</a>() {</div>
<div class="line">    <span class="comment">// CPU executes this code at ~60 Hz (16.67ms per frame)</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Step 1: Calculate time delta (CPU reads high-precision timer)</span></div>
<div class="line">    <span class="keywordtype">float</span> currentFrame = glfwGetTime();  <span class="comment">// System call → CPU cache</span></div>
<div class="line">    <span class="keywordtype">double</span> dt = currentFrame - <a class="code" href="classApplication.html#a7e2800cbc39cb5864efacb202b6bfb68">lastFrame</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Step 2: Update simulation modules</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; module : modules) {</div>
<div class="line">        module-&gt;update(dt, simulationState);  <span class="comment">// Writes to RAM</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Step 3: Render everything</span></div>
<div class="line">    <a class="code" href="classApplication.html#a4e7a520d659593b385b246a43e604dfb">render3D</a>();  <span class="comment">// This triggers GPU commands</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassApplication_html_a4e7a520d659593b385b246a43e604dfb"><div class="ttname"><a href="classApplication.html#a4e7a520d659593b385b246a43e604dfb">Application::render3D</a></div><div class="ttdeci">void render3D()</div><div class="ttdoc">Render the 3D scene (cube + axes)</div><div class="ttdef"><b>Definition:</b> application.cpp:597</div></div>
<div class="ttc" id="aclassApplication_html_a7e2800cbc39cb5864efacb202b6bfb68"><div class="ttname"><a href="classApplication.html#a7e2800cbc39cb5864efacb202b6bfb68">Application::lastFrame</a></div><div class="ttdeci">float lastFrame</div><div class="ttdoc">Timestamp of last frame (seconds)</div><div class="ttdef"><b>Definition:</b> application.h:52</div></div>
<div class="ttc" id="aclassApplication_html_af44c742342adf5305e430ff293f147c1"><div class="ttname"><a href="classApplication.html#af44c742342adf5305e430ff293f147c1">Application::tick</a></div><div class="ttdeci">void tick()</div><div class="ttdoc">Execute one frame: update simulation, render 3D, render UI.</div><div class="ttdef"><b>Definition:</b> application.cpp:376</div></div>
</div><!-- fragment --><p><b>Memory Location:</b> Your code is in RAM, executing on CPU cores. The <code>simulationState</code> object lives in <b>heap memory (RAM)</b>.</p>
<p><b>CPU Cache:</b> When modules access <code>simulationState.attitude.quaternion</code>, the CPU checks:</p><ol type="1">
<li><b>L1 cache</b> (4 cycles, ~1ns) - Private per CPU core, ~32-64 KB</li>
<li><b>L2 cache</b> (12 cycles, ~3ns) - Private per CPU core, ~256-512 KB</li>
<li><b>L3 cache</b> (40 cycles, ~12ns) - Shared across all cores, ~8-32 MB</li>
<li><b>RAM</b> (200+ cycles, ~60ns) - If cache miss, fetch from main memory</li>
</ol>
<p><b>Why This Matters:</b></p><ul>
<li>Sequential memory access (like looping through <code>state.rotor.rpm</code> vector) is <b>fast</b> because CPU prefetches next cache line</li>
<li>Random memory access (like pointer chasing) causes cache misses</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md88"></a>
1.2 Module Updates (Pure CPU Work)</h2>
<p>Example: <code><a class="el" href="quaternion__demo_8cpp.html">src/modules/quaternion_demo.cpp</a>:37-72</code></p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classQuaternionDemoModule.html#ad7ebf21527722e8f6efb2eae537da1d0">QuaternionDemoModule::update</a>(<span class="keywordtype">double</span> dt, <a class="code" href="structSimulationState.html">SimulationState</a>&amp; state) {</div>
<div class="line">    <span class="comment">// All of this happens in RAM, executed by CPU</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Read angular velocity (CPU loads from RAM → L1 cache)</span></div>
<div class="line">    glm::dvec3 omega_deg_s = state.<a class="code" href="structSimulationState.html#a1d3ee7c82a58aa775399979710170812">angular_rate_deg_per_sec</a>;</div>
<div class="line">    glm::dvec3 omega_rad_s = glm::radians(omega_deg_s);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Quaternion integration (CPU ALU performs math)</span></div>
<div class="line">    glm::dquat q_current = state.attitude.<a class="code" href="structSimulationState.html#a20e333ffdfe2eab81d5e0c9df189595d">quaternion</a>;</div>
<div class="line">    glm::dquat omega_quat = glm::dquat(0.0, omega_rad_s.x, omega_rad_s.y, omega_rad_s.z);</div>
<div class="line">    glm::dquat q_dot = 0.5 * omega_quat * q_current;</div>
<div class="line">    glm::dquat q_new = q_current + dt * q_dot;</div>
<div class="line">    q_new = glm::normalize(q_new);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Write back to state (CPU writes to RAM, invalidates cache)</span></div>
<div class="line">    state.attitude.<a class="code" href="structSimulationState.html#a20e333ffdfe2eab81d5e0c9df189595d">quaternion</a> = q_new;</div>
<div class="line">    state.attitude.euler_deg = quaternionToEuler(q_new);  <span class="comment">// More CPU math</span></div>
<div class="line">    state.attitude.<a class="code" href="structSimulationState.html#acef78e29043f3602fe7456343636eb07">model_matrix</a> = quaternionToDCM(q_new); <span class="comment">// 4x4 matrix ops</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassQuaternionDemoModule_html_ad7ebf21527722e8f6efb2eae537da1d0"><div class="ttname"><a href="classQuaternionDemoModule.html#ad7ebf21527722e8f6efb2eae537da1d0">QuaternionDemoModule::update</a></div><div class="ttdeci">void update(double dt, SimulationState &amp;state) override</div><div class="ttdoc">Update attitude quaternion based on angular velocity.</div><div class="ttdef"><b>Definition:</b> quaternion_demo.cpp:37</div></div>
<div class="ttc" id="astructSimulationState_html"><div class="ttname"><a href="structSimulationState.html">SimulationState</a></div><div class="ttdoc">Central shared state for the entire simulation.</div><div class="ttdef"><b>Definition:</b> simulation_state.h:28</div></div>
<div class="ttc" id="astructSimulationState_html_a1d3ee7c82a58aa775399979710170812"><div class="ttname"><a href="structSimulationState.html#a1d3ee7c82a58aa775399979710170812">SimulationState::angular_rate_deg_per_sec</a></div><div class="ttdeci">glm::dvec3 angular_rate_deg_per_sec</div><div class="ttdoc">Angular velocity (deg/s) about body axes.</div><div class="ttdef"><b>Definition:</b> simulation_state.h:33</div></div>
<div class="ttc" id="astructSimulationState_html_a20e333ffdfe2eab81d5e0c9df189595d"><div class="ttname"><a href="structSimulationState.html#a20e333ffdfe2eab81d5e0c9df189595d">SimulationState::quaternion</a></div><div class="ttdeci">std::array&lt; double, 4 &gt; quaternion</div><div class="ttdoc">Current attitude quaternion [w, x, y, z].</div><div class="ttdef"><b>Definition:</b> simulation_state.h:31</div></div>
<div class="ttc" id="astructSimulationState_html_acef78e29043f3602fe7456343636eb07"><div class="ttname"><a href="structSimulationState.html#acef78e29043f3602fe7456343636eb07">SimulationState::model_matrix</a></div><div class="ttdeci">glm::mat4 model_matrix</div><div class="ttdoc">Model transformation matrix for rendering.</div><div class="ttdef"><b>Definition:</b> simulation_state.h:32</div></div>
</div><!-- fragment --><p><b>CPU Execution Details:</b></p><ul>
<li><b>Instruction Decode:</b> CPU decodes x86-64 instructions (ADD, MUL, LOAD, STORE)</li>
<li><b>Vector Units:</b> GLM uses SIMD (SSE/AVX) - processes 4 floats/doubles in parallel on CPU</li>
<li><b>Branch Prediction:</b> CPU predicts <code>if</code> statements to avoid pipeline stalls</li>
<li><b>Out-of-Order Execution:</b> CPU reorders instructions to maximize ALU utilization</li>
</ul>
<p><b>Memory Writes:</b> When you write <code>state.attitude.quaternion = q_new</code>:</p><ol type="1">
<li>CPU updates L1 cache (write-back policy)</li>
<li>L1 cache marks line as "dirty"</li>
<li>Eventually flushed to L2 → L3 → RAM</li>
<li>Other CPU cores see updated value via cache coherency protocol (MESI)</li>
</ol>
<hr  />
<h2><a class="anchor" id="autotoc_md90"></a>
1.3 ImGui Vertex Generation</h2>
<p>When you call <code>ImGui::Text("Hello")</code>, ImGui builds vertex data <b>in RAM</b>:</p>
<div class="fragment"><div class="line"><span class="comment">// Simplified version of what ImGui does internally</span></div>
<div class="line"><span class="keyword">struct </span>ImDrawVert {</div>
<div class="line">    ImVec2 pos;   <span class="comment">// 8 bytes (x, y) - screen coordinates</span></div>
<div class="line">    ImVec2 uv;    <span class="comment">// 8 bytes (u, v) - texture coordinates</span></div>
<div class="line">    ImU32 col;    <span class="comment">// 4 bytes (RGBA) - vertex color</span></div>
<div class="line">};  <span class="comment">// Total: 20 bytes per vertex</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// For each UI element, ImGui generates triangles</span></div>
<div class="line"><span class="comment">// Example: A rectangle (2 triangles = 6 vertices)</span></div>
<div class="line">ImDrawVert vertices[6] = {</div>
<div class="line">    {{x0, y0}, {0, 0}, color},  <span class="comment">// Triangle 1</span></div>
<div class="line">    {{x1, y0}, {1, 0}, color},</div>
<div class="line">    {{x0, y1}, {0, 1}, color},</div>
<div class="line">    {{x0, y1}, {0, 1}, color},  <span class="comment">// Triangle 2</span></div>
<div class="line">    {{x1, y0}, {1, 0}, color},</div>
<div class="line">    {{x1, y1}, {1, 1}, color}</div>
<div class="line">};</div>
</div><!-- fragment --><p><b>Memory Location:</b> This vertex array is allocated in <b>heap memory (RAM)</b> via <code>malloc()</code> or <code>new</code>.</p>
<p><b>Buffer Size:</b> For a complex UI with 1000 widgets:</p><ul>
<li>~10,000 vertices × 20 bytes = <b>200 KB</b> in RAM</li>
<li>Small enough to fit entirely in CPU L3 cache</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md92"></a>
1.4 OpenGL Command Submission</h2>
<p>File: <code><a class="el" href="renderer_8cpp.html">src/render/renderer.cpp</a>:78-85</code></p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classRenderer.html#a02a137957c8783a44df5cad4b5e1b635">Renderer::renderFrame</a>(<span class="keyword">const</span> <a class="code" href="classTransform.html">Transform</a>&amp; transform) {</div>
<div class="line">    <span class="comment">// CPU prepares uniform data in RAM</span></div>
<div class="line">    glm::mat4 mvp = transform.<a class="code" href="classTransform.html#a11fd76e01c56ea2a0c3d51f91209e430">projection</a> * transform.<a class="code" href="classTransform.html#ac8b39784d6f10a8f64749d271192646c">view</a> * transform.<a class="code" href="classTransform.html#a59fc1b7a6ee66a26d4e969213ad97aa7">model</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// CPU tells GPU to use shader program</span></div>
<div class="line">    glUseProgram(shaderProgram);  <span class="comment">// ← Driver queues command</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// CPU uploads matrix to GPU</span></div>
<div class="line">    glUniformMatrix4fv(mvpLocation, 1, GL_FALSE, glm::value_ptr(mvp));  <span class="comment">// ← DMA transfer scheduled</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// CPU tells GPU to bind VAO (GPU state change)</span></div>
<div class="line">    glBindVertexArray(vao);  <span class="comment">// ← Command queued</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// CPU tells GPU to draw triangles</span></div>
<div class="line">    glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0);  <span class="comment">// ← Render command queued</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassRenderer_html_a02a137957c8783a44df5cad4b5e1b635"><div class="ttname"><a href="classRenderer.html#a02a137957c8783a44df5cad4b5e1b635">Renderer::renderFrame</a></div><div class="ttdeci">void renderFrame()</div><div class="ttdoc">Render a frame (legacy 2D mode - deprecated)</div><div class="ttdef"><b>Definition:</b> renderer.cpp:86</div></div>
<div class="ttc" id="aclassTransform_html"><div class="ttname"><a href="classTransform.html">Transform</a></div><div class="ttdef"><b>Definition:</b> transform.h:7</div></div>
<div class="ttc" id="aclassTransform_html_a11fd76e01c56ea2a0c3d51f91209e430"><div class="ttname"><a href="classTransform.html#a11fd76e01c56ea2a0c3d51f91209e430">Transform::projection</a></div><div class="ttdeci">glm::mat4 projection</div><div class="ttdef"><b>Definition:</b> transform.h:11</div></div>
<div class="ttc" id="aclassTransform_html_a59fc1b7a6ee66a26d4e969213ad97aa7"><div class="ttname"><a href="classTransform.html#a59fc1b7a6ee66a26d4e969213ad97aa7">Transform::model</a></div><div class="ttdeci">glm::mat4 model</div><div class="ttdef"><b>Definition:</b> transform.h:9</div></div>
<div class="ttc" id="aclassTransform_html_ac8b39784d6f10a8f64749d271192646c"><div class="ttname"><a href="classTransform.html#ac8b39784d6f10a8f64749d271192646c">Transform::view</a></div><div class="ttdeci">glm::mat4 view</div><div class="ttdef"><b>Definition:</b> transform.h:10</div></div>
</div><!-- fragment --><p><b>What Happens Under the Hood:</b></p>
<ol type="1">
<li><b>CPU writes commands to a ring buffer</b> (shared memory between driver and kernel)</li>
<li><b>OpenGL driver</b> (running in kernel space) validates commands</li>
<li><b>DMA (Direct Memory Access)</b> transfers commands to GPU memory <b>without CPU involvement</b></li>
<li><b>GPU command processor</b> wakes up and starts executing</li>
</ol>
<p><b>Critical Detail:</b> <code>glDrawElements()</code> does NOT execute immediately! It's <b>queued</b> and executes later when you call <code>glfwSwapBuffers()</code>.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md94"></a>
Stage 2: PCIe Bus Transfer</h1>
<h2><a class="anchor" id="autotoc_md95"></a>
2.1 CPU → GPU Communication</h2>
<div class="fragment"><div class="line">┌──────────────┐          PCIe 3.0 x16          ┌──────────────┐</div>
<div class="line">│     CPU      │  ←─────────────────────────→   │     GPU      │</div>
<div class="line">│  (RAM side)  │    16 GB/s bidirectional       │  (VRAM side) │</div>
<div class="line">└──────────────┘                                └──────────────┘</div>
</div><!-- fragment --><p><b>PCIe Bus Specifications:</b></p><ul>
<li><b>PCIe 3.0 x16:</b> ~16 GB/s bandwidth (32 GB/s for PCIe 4.0)</li>
<li><b>Latency:</b> ~1-2 microseconds for command submission</li>
<li><b>DMA Transfer:</b> GPU can read RAM directly without CPU, but slower than VRAM</li>
</ul>
<p><b>What Gets Transferred:</b></p>
<ol type="1">
<li><b>Vertex Data</b> (if not already in VRAM):<ul>
<li>VAO/VBO uploaded once at init via <code>glBufferData()</code></li>
<li>Stays in GPU VRAM until deleted</li>
</ul>
</li>
<li><b>Uniform Data</b> (uploaded every frame):<ul>
<li><code>mvp</code> matrix (64 bytes)</li>
<li>Light positions, colors (if used)</li>
</ul>
</li>
<li><b>Texture Data</b> (uploaded once):<ul>
<li>Font atlases for ImGui</li>
<li>Off-screen render target textures</li>
</ul>
</li>
<li><b>Command Buffer:</b><ul>
<li>GPU instructions (use program, bind VAO, draw)</li>
</ul>
</li>
</ol>
<p><b>File Reference:</b> Vertex upload happens in <code><a class="el" href="renderer_8cpp.html">src/render/renderer.cpp</a>:125-150</code></p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Renderer::setupCubeGeometry() {</div>
<div class="line">    <span class="keywordtype">float</span> vertices[] = { <span class="comment">/* 8 vertices × 3 floats = 96 bytes */</span> };</div>
<div class="line"> </div>
<div class="line">    glGenBuffers(1, &amp;vbo);</div>
<div class="line">    glBindBuffer(GL_ARRAY_BUFFER, vbo);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// THIS is the PCIe transfer: RAM → GPU VRAM</span></div>
<div class="line">    glBufferData(GL_ARRAY_BUFFER,         <span class="comment">// Target</span></div>
<div class="line">                 <span class="keyword">sizeof</span>(vertices),         <span class="comment">// 96 bytes</span></div>
<div class="line">                 vertices,                 <span class="comment">// Source address in RAM</span></div>
<div class="line">                 GL_STATIC_DRAW);          <span class="comment">// Hint: data won&#39;t change</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// GPU now has a copy in VRAM. CPU can free RAM copy.</span></div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md97"></a>
Stage 3: GPU Side - Graphics Card</h1>
<h2><a class="anchor" id="autotoc_md98"></a>
3.1 GPU Architecture Overview</h2>
<p>Modern GPUs (NVIDIA/AMD) have this structure:</p>
<div class="fragment"><div class="line">┌─────────────────────────────────────────────────────┐</div>
<div class="line">│ GPU Die                                             │</div>
<div class="line">├─────────────────────────────────────────────────────┤</div>
<div class="line">│                                                     │</div>
<div class="line">│  ┌──────────────────────────────────────────────┐  │</div>
<div class="line">│  │ Graphics Processing Clusters (GPCs)          │  │</div>
<div class="line">│  │  Each GPC contains:                          │  │</div>
<div class="line">│  │    • Streaming Multiprocessors (SMs)         │  │</div>
<div class="line">│  │    • Texture Units                           │  │</div>
<div class="line">│  │    • Raster Engines                          │  │</div>
<div class="line">│  └──────────────────────────────────────────────┘  │</div>
<div class="line">│                                                     │</div>
<div class="line">│  Streaming Multiprocessor (SM) - THE CORE UNIT:    │</div>
<div class="line">│  ┌────────────────────────────────────┐            │</div>
<div class="line">│  │ • 128 CUDA cores (NVIDIA)          │            │</div>
<div class="line">│  │ • 64 KB shared memory (L1 cache)   │            │</div>
<div class="line">│  │ • 65536 registers                  │            │</div>
<div class="line">│  │ • Warp Scheduler (32 threads/warp) │            │</div>
<div class="line">│  └────────────────────────────────────┘            │</div>
<div class="line">│  × 80 SMs on RTX 3080 = 10,240 cores!             │</div>
<div class="line">│                                                     │</div>
<div class="line">│  ┌────────────────────────────────────┐            │</div>
<div class="line">│  │ L2 Cache (6 MB)                    │            │</div>
<div class="line">│  └────────────────────────────────────┘            │</div>
<div class="line">│                     ↓                               │</div>
<div class="line">│  ┌────────────────────────────────────┐            │</div>
<div class="line">│  │ VRAM (GDDR6, 10-24 GB)             │            │</div>
<div class="line">│  │ Bandwidth: 760 GB/s (vs 50 GB/s    │            │</div>
<div class="line">│  │ for system RAM!)                   │            │</div>
<div class="line">│  └────────────────────────────────────┘            │</div>
<div class="line">│                                                     │</div>
<div class="line">└─────────────────────────────────────────────────────┘</div>
</div><!-- fragment --><p><b>Key Numbers (RTX 3080 example):</b></p><ul>
<li><b>10,240 CUDA cores</b> (shader execution units)</li>
<li><b>68 Streaming Multiprocessors</b> (80 on 3090)</li>
<li><b>10 GB GDDR6X VRAM</b> (760 GB/s bandwidth!)</li>
<li><b>1.71 GHz boost clock</b></li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md100"></a>
3.2 GPU Memory Hierarchy</h2>
<div class="fragment"><div class="line">┌────────────────────────────────────────────────┐</div>
<div class="line">│ Registers (per thread)                         │</div>
<div class="line">│ • 255 registers × 4 bytes = 1 KB per thread    │</div>
<div class="line">│ • Access: 0 cycles, instant                    │</div>
<div class="line">│ • Scope: Private to each shader thread         │</div>
<div class="line">└────────────────────────────────────────────────┘</div>
<div class="line">                    ↓</div>
<div class="line">┌────────────────────────────────────────────────┐</div>
<div class="line">│ Shared Memory / L1 Cache (per SM)              │</div>
<div class="line">│ • 64-128 KB configurable                       │</div>
<div class="line">│ • Access: ~5 cycles                            │</div>
<div class="line">│ • Scope: Shared by 32-thread warp              │</div>
<div class="line">└────────────────────────────────────────────────┘</div>
<div class="line">                    ↓</div>
<div class="line">┌────────────────────────────────────────────────┐</div>
<div class="line">│ L2 Cache (global)                              │</div>
<div class="line">│ • 4-6 MB across entire GPU                     │</div>
<div class="line">│ • Access: ~200 cycles                          │</div>
<div class="line">│ • Scope: Shared by all SMs                     │</div>
<div class="line">└────────────────────────────────────────────────┘</div>
<div class="line">                    ↓</div>
<div class="line">┌────────────────────────────────────────────────┐</div>
<div class="line">│ VRAM (GDDR6)                                   │</div>
<div class="line">│ • 8-24 GB                                      │</div>
<div class="line">│ • Access: ~400-800 cycles                      │</div>
<div class="line">│ • Bandwidth: 500-1000 GB/s                     │</div>
<div class="line">│ • Scope: Global, persistent                    │</div>
<div class="line">└────────────────────────────────────────────────┘</div>
</div><!-- fragment --><p><b>Your Data:</b></p><ul>
<li><b>VBO (cube vertices):</b> Lives in VRAM, cached in L2</li>
<li><b>Uniform (mvp matrix):</b> Uploaded to constant memory, cached heavily</li>
<li><b>Framebuffer:</b> VRAM, written by fragment shaders</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md102"></a>
3.3 Vertex Shader Execution</h2>
<p>File: <code>shaders/vertex3D.glsl</code></p>
<div class="fragment"><div class="line">#version 330 core</div>
<div class="line">layout (location = 0) in vec3 aPos;      // Input from VBO in VRAM</div>
<div class="line">layout (location = 1) in vec3 aColor;</div>
<div class="line"> </div>
<div class="line">out vec3 vertexColor;  // Output to fragment shader (via interpolator)</div>
<div class="line"> </div>
<div class="line">uniform mat4 model;        // Uploaded from CPU</div>
<div class="line">uniform mat4 view;</div>
<div class="line">uniform mat4 projection;</div>
<div class="line"> </div>
<div class="line">void main() {</div>
<div class="line">    // THIS CODE RUNS ON GPU SHADER CORES!</div>
<div class="line">    gl_Position = projection * view * model * vec4(aPos, 1.0);</div>
<div class="line">    vertexColor = aColor;</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>GPU Execution Flow:</b></p>
<ol type="1">
<li><b>Input Assembly:</b><ul>
<li>GPU fetches vertex data from VBO in VRAM</li>
<li>For cube: 8 vertices fetched (24 bytes each = 192 bytes total)</li>
</ul>
</li>
<li><b>Vertex Shader Invocation:</b><ul>
<li><b>One thread per vertex</b> launched on GPU</li>
<li>8 threads for cube (trivial workload)</li>
<li>For complex model with 100,000 vertices → 100,000 parallel threads!</li>
</ul>
</li>
<li><b>Parallel Execution on Streaming Multiprocessor:</b> <div class="fragment"><div class="line">Warp 0 (32 threads processing 32 vertices):</div>
<div class="line">Thread 0: v0.pos = projection * view * model * vec4(v0.aPos, 1.0)</div>
<div class="line">Thread 1: v1.pos = projection * view * model * vec4(v1.aPos, 1.0)</div>
<div class="line">Thread 2: v2.pos = projection * view * model * vec4(v2.aPos, 1.0)</div>
<div class="line">...</div>
<div class="line">Thread 31: v31.pos = ...</div>
<div class="line"> </div>
<div class="line">All execute SAME instruction simultaneously (SIMT - Single Instruction Multiple Thread)</div>
</div><!-- fragment --></li>
<li><b>Memory Access Pattern:</b><ul>
<li><code>aPos</code> loaded from VRAM (sequential access, coalesced)</li>
<li><code>model/view/projection</code> loaded from constant memory (broadcast to all threads)</li>
<li>Matrix math performed in registers (FMAD units - Fused Multiply-Add)</li>
</ul>
</li>
<li><b>Output:</b><ul>
<li><code>gl_Position</code> written to intermediate buffer</li>
<li><code>vertexColor</code> written to varying buffer (for interpolation)</li>
</ul>
</li>
</ol>
<p><b>Performance:</b></p><ul>
<li><b>Throughput:</b> RTX 3080 can process ~10 billion vertices/sec</li>
<li><b>Bottleneck for simple cube:</b> Memory bandwidth (VRAM access), not compute</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md104"></a>
3.4 Rasterization (Fixed-Function Hardware)</h2>
<p>After vertex shader, GPU has 8 transformed vertices. Now it converts triangles to pixels:</p>
<div class="fragment"><div class="line">   Triangle in Clip Space              Rasterized Pixels</div>
<div class="line">    (vertex shader output)         (fragment shader input)</div>
<div class="line"> </div>
<div class="line">         v1 (x,y,z)                    ████████████</div>
<div class="line">        /  \                           ██████████████</div>
<div class="line">       /    \                          ████████████████</div>
<div class="line">      /      \           ──────►       ██████████████████</div>
<div class="line">     /        \                        ████████████████</div>
<div class="line">    /          \                       ██████████████</div>
<div class="line">v0 ───────────── v2                    ████████████</div>
</div><!-- fragment --><p><b>Rasterizer Hardware:</b></p><ul>
<li><b>Dedicated silicon</b> (not programmable)</li>
<li><b>Edge equations:</b> Determines which pixels are inside triangle</li>
<li><b>Interpolation:</b> Calculates <code>vertexColor</code> for each pixel (barycentric interpolation)</li>
</ul>
<p><b>Example:</b> </p><div class="fragment"><div class="line">Vertex colors:</div>
<div class="line">  v0 = red   (1, 0, 0)</div>
<div class="line">  v1 = green (0, 1, 0)</div>
<div class="line">  v2 = blue  (0, 0, 1)</div>
<div class="line"> </div>
<div class="line">Pixel at center:</div>
<div class="line">  color = (1/3 * red) + (1/3 * green) + (1/3 * blue) = gray</div>
</div><!-- fragment --><p><b>Output:</b> Fragment stream (one fragment per pixel covered by triangle)</p>
<hr  />
<h2><a class="anchor" id="autotoc_md106"></a>
3.5 Fragment Shader Execution</h2>
<p>File: <code>shaders/fragment3D.glsl</code></p>
<div class="fragment"><div class="line">#version 330 core</div>
<div class="line">in vec3 vertexColor;  // Interpolated from vertex shader</div>
<div class="line">out vec4 FragColor;   // Output to framebuffer</div>
<div class="line"> </div>
<div class="line">void main() {</div>
<div class="line">    // THIS RUNS ONCE PER PIXEL, IN PARALLEL</div>
<div class="line">    FragColor = vec4(vertexColor, 1.0);</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>GPU Execution:</b></p>
<p>Suppose cube covers 10,000 pixels on screen:</p>
<ol type="1">
<li><b>Fragment Shader Invocation:</b><ul>
<li><b>10,000 threads launched</b> (one per pixel)</li>
<li>Grouped into warps of 32 threads</li>
</ul>
</li>
<li><b>Parallel Execution:</b> <div class="fragment"><div class="line">Warp 0 (32 pixels):</div>
<div class="line">Thread 0: FragColor[pixel_0] = vec4(interpolated_color_0, 1.0)</div>
<div class="line">Thread 1: FragColor[pixel_1] = vec4(interpolated_color_1, 1.0)</div>
<div class="line">...</div>
<div class="line">Thread 31: FragColor[pixel_31] = vec4(interpolated_color_31, 1.0)</div>
</div><!-- fragment --></li>
<li><b>Memory Writes:</b><ul>
<li>Each thread writes to framebuffer in VRAM</li>
<li>Framebuffer is typically <b>RGBA8</b> (4 bytes per pixel)</li>
<li>For 1920×1080: 8.3 MB framebuffer</li>
</ul>
</li>
<li><b>Depth Test (Hardware):</b><ul>
<li>Before writing color, GPU checks depth buffer</li>
<li>If <code>new_depth &lt; current_depth</code>, write pixel (closer object wins)</li>
<li>Depth buffer in VRAM (4 bytes per pixel = 8.3 MB for 1080p)</li>
</ul>
</li>
</ol>
<hr  />
<h2><a class="anchor" id="autotoc_md108"></a>
3.6 Framebuffer Operations</h2>
<p>After fragment shader, GPU performs:</p>
<ol type="1">
<li><b>Depth Test:</b> <div class="fragment"><div class="line"><span class="keywordflow">if</span> (fragment.depth &lt; depth_buffer[x][y]) {</div>
<div class="line">    <span class="comment">// This fragment is in front</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    discard;  <span class="comment">// Behind existing geometry</span></div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><b>Stencil Test:</b> (not used in this project)</li>
<li><b>Blending:</b> (for transparent objects) <div class="fragment"><div class="line"><span class="comment">// If alpha blending enabled:</span></div>
<div class="line">final_color = src_color * src_alpha + dst_color * (1 - src_alpha);</div>
</div><!-- fragment --></li>
<li><b>Write to Framebuffer:</b> <div class="fragment"><div class="line">framebuffer[y * width + x] = final_color;</div>
<div class="line">depth_buffer[y * width + x] = fragment.depth;</div>
</div><!-- fragment --></li>
</ol>
<p><b>Memory Location:</b> All framebuffers are in <b>GPU VRAM</b>.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md110"></a>
Stage 4: Display Output</h1>
<h2><a class="anchor" id="autotoc_md111"></a>
4.1 Swap Buffers</h2>
<p>File: <code><a class="el" href="application_8cpp.html">src/app/application.cpp</a>:522</code></p>
<div class="fragment"><div class="line">glfwSwapBuffers(window);  <span class="comment">// ← This is when GPU work ACTUALLY happens!</span></div>
</div><!-- fragment --><p><b>What This Does:</b></p>
<ol type="1">
<li><b>CPU blocks</b> until GPU finishes all queued commands (synchronization point)</li>
<li><b>GPU flushes all pending work:</b><ul>
<li>Vertex shaders execute</li>
<li>Rasterization occurs</li>
<li>Fragment shaders execute</li>
<li>Framebuffer writes complete</li>
</ul>
</li>
<li><b>Double buffering swap:</b> <div class="fragment"><div class="line">Before swap:</div>
<div class="line">  Front buffer (scanout to monitor) = Previous frame</div>
<div class="line">  Back buffer (GPU rendering target) = Current frame</div>
<div class="line"> </div>
<div class="line">After swap:</div>
<div class="line">  Front buffer = Current frame  ← Monitor now displays this</div>
<div class="line">  Back buffer = (empty, ready for next frame)</div>
</div><!-- fragment --></li>
<li><b>Display controller</b> starts scanning front buffer</li>
</ol>
<hr  />
<h2><a class="anchor" id="autotoc_md113"></a>
4.2 Display Controller Scanout</h2>
<div class="fragment"><div class="line">┌──────────────────────────────────────────────┐</div>
<div class="line">│ GPU VRAM - Front Buffer (framebuffer)        │</div>
<div class="line">│ 1920×1080 pixels × 4 bytes = 8.3 MB          │</div>
<div class="line">└──────────────────────────────────────────────┘</div>
<div class="line">                    │</div>
<div class="line">                    │ Display controller reads at 60 Hz</div>
<div class="line">                    ↓</div>
<div class="line">┌──────────────────────────────────────────────┐</div>
<div class="line">│ Display Controller (on GPU die)              │</div>
<div class="line">│ • Scans framebuffer top-to-bottom            │</div>
<div class="line">│ • Sends pixel data to monitor via HDMI/DP    │</div>
<div class="line">│ • Rate: 60 Hz (or 144 Hz for gaming)         │</div>
<div class="line">└──────────────────────────────────────────────┘</div>
<div class="line">                    │</div>
<div class="line">                    │ Digital signal (TMDS encoding)</div>
<div class="line">                    ↓</div>
<div class="line">┌──────────────────────────────────────────────┐</div>
<div class="line">│ HDMI / DisplayPort Cable                     │</div>
<div class="line">│ Bandwidth: 18 Gbps (HDMI 2.0)                │</div>
<div class="line">└──────────────────────────────────────────────┘</div>
<div class="line">                    │</div>
<div class="line">                    ↓</div>
<div class="line">┌──────────────────────────────────────────────┐</div>
<div class="line">│ Monitor                                      │</div>
<div class="line">│ • LCD panel controller                       │</div>
<div class="line">│ • Pixel transistors switch                   │</div>
<div class="line">│ • Backlight illuminates                      │</div>
<div class="line">│ • You see the image!                         │</div>
<div class="line">└──────────────────────────────────────────────┘</div>
</div><!-- fragment --><p><b>Refresh Cycle (60 Hz):</b></p><ul>
<li>Every 16.67ms, display controller reads entire framebuffer</li>
<li>Scans line-by-line (horizontal scanout)</li>
<li><b>V-Sync:</b> CPU/GPU wait for vertical blanking interval before swapping</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md115"></a>
Complete Frame Timing Breakdown</h1>
<p>Let's trace <b>one frame</b> of AeroDynControlRig at 60 FPS:</p>
<div class="fragment"><div class="line">Time (ms)  Component       Action</div>
<div class="line">─────────────────────────────────────────────────────────────────</div>
<div class="line">0.00       CPU             Application::tick() starts</div>
<div class="line">0.05       CPU             Modules update SimulationState (RAM writes)</div>
<div class="line">0.10       CPU             ImGui::NewFrame() starts</div>
<div class="line">0.15       CPU             Panels draw UI (generates vertex data in RAM)</div>
<div class="line">0.20       CPU             ImGui::Render() finalizes draw lists</div>
<div class="line">0.25       CPU             renderer.renderFrame() queues OpenGL commands</div>
<div class="line">0.30       CPU             glDrawElements() queued (not executed yet!)</div>
<div class="line">0.35       CPU             ImGui_ImplOpenGL3_RenderDrawData() queues UI draw</div>
<div class="line">0.40       CPU             glfwSwapBuffers() called</div>
<div class="line">           ───────────────────────────────────────────────────────</div>
<div class="line">0.41       DMA             Command buffer → GPU via PCIe (2 μs)</div>
<div class="line">           ───────────────────────────────────────────────────────</div>
<div class="line">0.42       GPU             Command processor wakes up</div>
<div class="line">0.43       GPU             Vertex shader launches (8 threads for cube)</div>
<div class="line">0.44       GPU             Rasterizer generates fragments</div>
<div class="line">0.45       GPU             Fragment shader executes (10,000 threads)</div>
<div class="line">0.50       GPU             Writes to framebuffer in VRAM</div>
<div class="line">0.55       GPU             Repeats for ImGui geometry (1000s of quads)</div>
<div class="line">1.20       GPU             All rendering complete</div>
<div class="line">1.21       GPU             Signals CPU (fence)</div>
<div class="line">           ───────────────────────────────────────────────────────</div>
<div class="line">1.22       CPU             glfwSwapBuffers() returns</div>
<div class="line">1.23       CPU             glfwPollEvents() processes input</div>
<div class="line">1.25       CPU             Application::tick() returns</div>
<div class="line">           ───────────────────────────────────────────────────────</div>
<div class="line">           (Wait for V-Sync)</div>
<div class="line">           ───────────────────────────────────────────────────────</div>
<div class="line">16.67      Display Ctrl    Swaps front/back buffers</div>
<div class="line">16.67      Monitor         Starts scanning new framebuffer</div>
<div class="line">33.33      Monitor         Frame fully displayed</div>
<div class="line">           ───────────────────────────────────────────────────────</div>
<div class="line">           (Next frame starts at 16.67ms)</div>
</div><!-- fragment --><p><b>Total Frame Time:</b> 1.25ms CPU + wait until 16.67ms for V-Sync</p>
<p><b>GPU Utilization:</b> 1.2ms out of 16.67ms = <b>7% GPU load</b> (very light workload!)</p>
<hr  />
<h1><a class="anchor" id="autotoc_md117"></a>
Memory Bandwidth Analysis</h1>
<h2><a class="anchor" id="autotoc_md118"></a>
CPU Side (System RAM)</h2>
<div class="fragment"><div class="line">Operation                    Data Size    Bandwidth Used</div>
<div class="line">─────────────────────────────────────────────────────────</div>
<div class="line">SimulationState read/write   ~1 KB        L1 cache (negligible)</div>
<div class="line">ImGui vertex generation      ~200 KB      L3 cache hit (negligible)</div>
<div class="line">OpenGL driver overhead       ~10 KB       RAM access (~0.2 μs)</div>
<div class="line">─────────────────────────────────────────────────────────</div>
<div class="line">Total CPU→RAM:               ~211 KB      DDR4: 50 GB/s available</div>
<div class="line">Utilization:                              0.0004% (!!)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md119"></a>
PCIe Bus (CPU ↔ GPU)</h2>
<div class="fragment"><div class="line">Transfer                     Data Size    Transfer Time</div>
<div class="line">─────────────────────────────────────────────────────────</div>
<div class="line">Uniform data (matrices)      64 bytes     ~4 ns</div>
<div class="line">Command buffer               ~1 KB        ~60 ns</div>
<div class="line">ImGui vertex upload (dynamic) ~200 KB      ~12 μs</div>
<div class="line">─────────────────────────────────────────────────────────</div>
<div class="line">Total:                       ~201 KB      PCIe 3.0: 16 GB/s</div>
<div class="line">Utilization:                              0.001%</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md120"></a>
GPU Side (VRAM)</h2>
<div class="fragment"><div class="line">Operation                    Data Size    Bandwidth Used</div>
<div class="line">─────────────────────────────────────────────────────────</div>
<div class="line">VBO fetch (cube vertices)    192 bytes    L2 cache hit</div>
<div class="line">Framebuffer read (depth test) 8.3 MB      ~11 μs</div>
<div class="line">Framebuffer write (color)    8.3 MB       ~11 μs</div>
<div class="line">ImGui texture fetch          ~2 MB        ~2.6 μs</div>
<div class="line">─────────────────────────────────────────────────────────</div>
<div class="line">Total:                       ~18.6 MB     GDDR6: 760 GB/s</div>
<div class="line">Utilization:                              0.002%</div>
</div><!-- fragment --><p><b>Conclusion:</b> This app is <b>massively underutilizing</b> the GPU. You could render 1000× more geometry!</p>
<hr  />
<h1><a class="anchor" id="autotoc_md122"></a>
Optimization Insights</h1>
<h2><a class="anchor" id="autotoc_md123"></a>
Where Time Is Actually Spent</h2>
<p><b>Not GPU-bound:</b></p><ul>
<li>GPU utilization: ~7%</li>
<li>Rendering 36 triangles (cube) + ~1000 ImGui quads</li>
<li>GPU can handle millions of triangles</li>
</ul>
<p><b>Not CPU-bound:</b></p><ul>
<li>Quaternion math: ~0.05ms</li>
<li>ImGui layout: ~0.15ms</li>
<li>Total CPU work: ~1.2ms out of 16.67ms budget</li>
</ul>
<p><b>Actual Bottleneck:</b></p><ul>
<li><b>V-Sync wait</b> (14ms of idle time)</li>
<li>Limited by monitor refresh rate (60 Hz)</li>
</ul>
<h2><a class="anchor" id="autotoc_md124"></a>
If You Wanted to Optimize</h2>
<p><b>GPU Side:</b></p><ol type="1">
<li><b>Instanced rendering:</b> Draw 1000 cubes in one call <div class="fragment"><div class="line">glDrawElementsInstanced(GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0, 1000);</div>
</div><!-- fragment --></li>
<li><b>Texture atlasing:</b> Combine textures to reduce state changes</li>
<li><b>Compute shaders:</b> Offload physics to GPU (100× faster for parallel work)</li>
</ol>
<p><b>CPU Side:</b></p><ol type="1">
<li><b>SIMD optimization:</b> GLM already uses SSE/AVX</li>
<li><b>Multithreading:</b> Update modules in parallel (overkill for this app)</li>
<li><b>Cache optimization:</b> Store vectors-of-structs instead of structs-of-vectors</li>
</ol>
<p><b>But honestly:</b> This app is already <b>extremely efficient</b>. No optimization needed.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md126"></a>
Key Takeaways</h1>
<ol type="1">
<li><b>Your C++ code runs on CPU</b> and manipulates RAM</li>
<li><b>OpenGL commands are queued</b>, not immediate</li>
<li><b>PCIe bus transfers data</b> to GPU VRAM (once for static geometry)</li>
<li><b>GPU runs thousands of threads in parallel</b> (one per vertex, one per pixel)</li>
<li><b>Shaders execute on CUDA cores</b> with massive parallelism</li>
<li><b>Framebuffer lives in GPU VRAM</b> and is scanned by display controller</li>
<li><b>V-Sync synchronizes</b> CPU frame generation with monitor refresh</li>
</ol>
<hr  />
<h1><a class="anchor" id="autotoc_md128"></a>
Mapping to AeroDynControlRig Code</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">File   </th><th class="markdownTableHeadNone">What It Does   </th><th class="markdownTableHeadNone">Where It Executes    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code><a class="el" href="application_8cpp.html">application.cpp</a>:tick()</code>   </td><td class="markdownTableBodyNone">Main loop   </td><td class="markdownTableBodyNone">CPU (RAM)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code><a class="el" href="quaternion__demo_8cpp.html">quaternion_demo.cpp</a>:update()</code>   </td><td class="markdownTableBodyNone">Physics math   </td><td class="markdownTableBodyNone">CPU (L1/L2 cache)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code><a class="el" href="renderer_8cpp.html">renderer.cpp</a>:renderFrame()</code>   </td><td class="markdownTableBodyNone">Queue OpenGL commands   </td><td class="markdownTableBodyNone">CPU (sends to GPU)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>shaders/vertex3D.glsl</code>   </td><td class="markdownTableBodyNone"><a class="el" href="classTransform.html">Transform</a> vertices   </td><td class="markdownTableBodyNone"><b>GPU shader cores</b>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>shaders/fragment3D.glsl</code>   </td><td class="markdownTableBodyNone">Color pixels   </td><td class="markdownTableBodyNone"><b>GPU shader cores</b>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Framebuffer   </td><td class="markdownTableBodyNone">Store rendered image   </td><td class="markdownTableBodyNone"><b>GPU VRAM</b>   </td></tr>
</table>
<hr  />
<h1><a class="anchor" id="autotoc_md130"></a>
Related Documentation</h1>
<ul>
<li><a class="el" href="web_analogy.html">Web Development Analogy</a> - UI architecture mapping</li>
<li><a class="el" href="architecture.html">Architecture Guide</a> - High-level system design</li>
<li><code><a class="el" href="renderer_8h.html" title="Main 3D scene renderer using OpenGL 3.3.">src/render/renderer.h</a></code> - OpenGL rendering implementation</li>
<li><code>shaders/</code> - GLSL shader source code</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md132"></a>
Further Reading</h1>
<ul>
<li><a href="https://developer.nvidia.com/gpugems/gpugems3/contributors">GPU Gems (Free Online)</a> - Deep GPU optimization</li>
<li><a href="https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview">Khronos OpenGL Wiki</a> - Official pipeline docs</li>
<li><a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/">CUDA Programming Guide</a> - GPU architecture details</li>
<li><a href="https://www.agner.org/optimize/">Agner Fog's Optimization Manuals</a> - CPU microarchitecture </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
