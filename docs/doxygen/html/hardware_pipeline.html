<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AeroDynControlRig: Hardware Pipeline: RAM → CPU → GPU → Screen</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AeroDynControlRig
   </div>
   <div id="projectbrief">Flight control algorithm testbed with OpenGL 3D visualization and ImGui dashboard</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('hardware_pipeline.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Hardware Pipeline: RAM → CPU → GPU → Screen </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li></li>
<li></li>
</ul>
<ul>
<li>Understanding how OpenGL and ImGui work requires understanding the <b>hardware pipeline</b> -</li>
<li>how data flows from your RAM, through CPU caches, to the GPU, and finally to your screen.</li>
</ul>
<ul>
<li>This guide explains the complete journey with concrete examples from our codebase.</li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## The Big Picture: Two Processors on One Die</li>
</ul>
<ul>
<li>Modern CPUs (Intel, AMD Ryzen with integrated graphics) have <b>TWO processors on the same chip</b>:</li>
</ul>
<ul>
<li>1. <b>CPU cores</b> - Your main processor cores</li>
<li>- 4-16 high-performance cores</li>
<li>- Each has its own cache hierarchy: L1 (32 KB) → L2 (256 KB) → shared L3 (8-32 MB)</li>
<li>- Accesses system RAM (DDR4/DDR5)</li>
<li>- Good at: Sequential logic, branches, complex algorithms</li>
<li>- Bad at: Doing the same operation on millions of items</li>
</ul>
<ul>
<li>2. <b>iGPU (integrated GPU)</b> - Graphics processor on the same die</li>
<li>- Intel UHD Graphics, AMD Radeon Graphics, Apple M-series GPU</li>
<li>- 96-512 execution units (think of them like mini-cores)</li>
<li>- <b>Shares system RAM</b> with CPU (no dedicated VRAM!)</li>
<li>- Has its own L3 cache for graphics (separate from CPU L3)</li>
<li>- Good at: Doing the same operation on millions of items in parallel</li>
<li>- Bad at: Complex branching logic</li>
</ul>
<ul>
<li><b>Key insight for integrated GPUs</b>:</li>
<li>- CPU and GPU are on the <b>same physical die</b></li>
<li>- They <b>share the same system RAM</b> (DDR4/DDR5)</li>
<li>- Memory is partitioned: part for CPU, part reserved for GPU</li>
<li>- Data transfer is faster than discrete GPU (no PCIe!) but still requires explicit copies</li>
<li>- Memory bandwidth is shared (~50 GB/s split between CPU and GPU)</li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## What is OpenGL?</li>
</ul>
<ul>
<li>OpenGL is <b>NOT</b> a library that runs on the CPU or GPU. It's a <b>specification</b> - a contract.</li>
</ul>
<ul>
<li>Think of it like this:</li>
<li>- <b>HTTP</b> is a specification (protocol) for web communication</li>
<li>- <b>OpenGL</b> is a specification (API) for graphics communication</li>
</ul>
<ul>
<li>### OpenGL is a Command Queue Interface</li>
</ul>
<ul>
<li>When you call OpenGL functions like <code>glDrawElements()</code>, you are <b>NOT</b> executing graphics code.</li>
<li>You are <b>sending commands</b> to the GPU driver, which queues them for the GPU.</li>
</ul>
<ul>
<li>```cpp</li>
<li>// This does NOT execute rendering immediately!</li>
<li>glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0);</li>
</ul>
<ul>
<li>// This just adds a command to the queue:</li>
<li>// "Dear GPU, please draw 36 vertices as triangles"</li>
<li>```</li>
</ul>
<ul>
<li>The <b>actual rendering</b> happens on the GPU when:</li>
<li>1. You call <code>glFlush()</code> or <code>glFinish()</code> (explicit)</li>
<li>2. You call <code>glfwSwapBuffers()</code> (implicit flush)</li>
<li>3. The driver decides the queue is full enough</li>
</ul>
<ul>
<li>### Who Implements OpenGL?</li>
</ul>
<ul>
<li>- <b>NVIDIA</b> implements OpenGL for NVIDIA GPUs</li>
<li>- <b>AMD</b> implements OpenGL for AMD GPUs</li>
<li>- <b>Intel</b> implements OpenGL for Intel integrated graphics</li>
<li>- <b>Mesa</b> implements OpenGL for open-source drivers (Linux)</li>
</ul>
<ul>
<li>Each vendor writes a <b>driver</b> that translates OpenGL commands into GPU-specific machine code.</li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## What is ImGui?</li>
</ul>
<ul>
<li>ImGui is a <b>C++ library</b> that runs <b>100% on the CPU</b>.</li>
</ul>
<ul>
<li>### What ImGui Does:</li>
</ul>
<ul>
<li>1. <b>Processes UI logic</b> (button clicks, text input, layout calculations)</li>
<li>2. <b>CREATES vertex data</b> for UI elements (rectangles, text, images)</li>
<li>3. <b>Builds a draw list</b> - a list of triangles to draw with their positions, colors, UVs</li>
</ul>
<ul>
<li>### What ImGui Does NOT Do:</li>
</ul>
<ul>
<li>ImGui <b>does not render anything</b> itself. It just produces <b>data</b> (vertex arrays).</li>
</ul>
<ul>
<li>Think of ImGui like this:</li>
<li>``&lsquo;</li>
<li>You: "ImGui, I want a button labeled 'Start&amp;rsquo; at position (10, 20)"</li>
</ul>
<ul>
<li>ImGui: <em>calculates layout, checks mouse input</em></li>
<li>"Okay, I've CREATED this vertex data for you:</li>
</ul>
<ul>
<li>Button background (rectangle = 2 triangles = 6 vertices):</li>
<li>Vertex 0: position=(10, 20), color=(0.2, 0.3, 0.8, 1.0)</li>
<li>Vertex 1: position=(110, 20), color=(0.2, 0.3, 0.8, 1.0)</li>
<li>Vertex 2: position=(110, 60), color=(0.2, 0.3, 0.8, 1.0)</li>
<li>Vertex 3: position=(10, 20), color=(0.2, 0.3, 0.8, 1.0)</li>
<li>Vertex 4: position=(110, 60), color=(0.2, 0.3, 0.8, 1.0)</li>
<li>Vertex 5: position=(10, 60), color=(0.2, 0.3, 0.8, 1.0)</li>
</ul>
<ul>
<li>Text 'Start' (each letter = 2 triangles with texture coords):</li>
<li>Letter 'S': 6 vertices with UV coords to font atlas...</li>
<li>Letter 't': 6 vertices with UV coords to font atlas...</li>
<li>... etc</li>
</ul>
<ul>
<li>Total: 36 vertices in my draw list"</li>
</ul>
<ul>
<li>You: "Thanks! Now I'll use OpenGL to upload this to the GPU and render it"</li>
<li>```</li>
</ul>
<ul>
<li><b>ImGui is a geometry generator, not a renderer!</b></li>
</ul>
<ul>
<li>### ImGui Backends</li>
</ul>
<ul>
<li>To actually <b>display</b> the UI, ImGui needs a <b>rendering backend</b>:</li>
<li>- <code>imgui_impl_opengl3.cpp</code> - Uses OpenGL to render</li>
<li>- <code>imgui_impl_vulkan.cpp</code> - Uses Vulkan to render</li>
<li>- <code>imgui_impl_dx11.cpp</code> - Uses DirectX 11 to render</li>
</ul>
<ul>
<li>Our project uses **<code>imgui_impl_opengl3.cpp</code>**, which:</li>
<li>1. Takes ImGui's draw list (CPU data)</li>
<li>2. Uploads it to GPU via OpenGL</li>
<li>3. Issues OpenGL draw calls</li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## OpenGL VBO/VAO: Storage vs Creation</li>
</ul>
<ul>
<li><b>Critical distinction</b>: OpenGL provides <b>storage containers</b> for vertex data.</li>
<li>It does NOT create the vertex data itself!</li>
</ul>
<ul>
<li>### What YOU Do (<a class="el" href="classApplication.html" title="Main application orchestrating the simulation, rendering, and UI.">Application</a> Code)</li>
</ul>
<ul>
<li><b>You create the geometry</b> - you decide the vertex positions, colors, etc.</li>
</ul>
<ul>
<li><b>Example from our cube renderer</b> (<code><a class="el" href="renderer_8cpp.html">src/render/renderer.cpp</a></code>):</li>
</ul>
<ul>
<li>```cpp</li>
<li>void <a class="el" href="classRenderer.html#a628ba0693fd83815acac8c69b7dcf9f0" title="Initialize OpenGL resources (shaders, geometry buffers)">Renderer::init()</a> {</li>
<li>// YOU create the vertex data (geometry) in CPU memory</li>
<li>float vertices[] = {</li>
<li>// Position Color</li>
<li>-0.5f, -0.5f, -0.5f, 1.0f, 0.0f, 0.0f, // Red vertex</li>
<li>0.5f, -0.5f, -0.5f, 0.0f, 1.0f, 0.0f, // Green vertex</li>
<li>0.5f, 0.5f, -0.5f, 0.0f, 0.0f, 1.0f, // Blue vertex</li>
<li>// ... 33 more vertices</li>
<li>};</li>
</ul>
<ul>
<li>// YOU decided:</li>
<li>// - A cube has 8 corners = 36 vertices (with duplicates for colors)</li>
<li>// - Each vertex has position (x, y, z) and color (r, g, b)</li>
<li>// - Specific values: (-0.5, -0.5, -0.5) for first corner, etc.</li>
<li>}</li>
<li>```</li>
</ul>
<ul>
<li>### What OpenGL VBO Does (Storage Container)</li>
</ul>
<ul>
<li><b>VBO (Vertex Buffer Object)</b> is just a <b>storage container</b> on the GPU side.</li>
<li>Think of it like a <code>std::vector&lt;float&gt;</code> but in GPU memory.</li>
</ul>
<ul>
<li>```cpp</li>
<li>// Create an empty storage container on GPU</li>
<li>GLuint vbo;</li>
<li>glGenBuffers(1, &amp;vbo); // GPU: "I created an empty buffer with ID 42"</li>
</ul>
<ul>
<li>// Make it the "active" buffer (like selecting a file to edit)</li>
<li>glBindBuffer(GL_ARRAY_BUFFER, vbo); // GPU: "Buffer 42 is now active"</li>
</ul>
<ul>
<li>// Copy YOUR vertex data into the GPU storage container</li>
<li>glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</li>
<li>// ^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^^^^ ^^^^^^^^</li>
<li>// Where to put it How big Pointer to YOUR data</li>
</ul>
<ul>
<li>// GPU: "I copied your 216 bytes of data into buffer 42"</li>
<li>```</li>
</ul>
<ul>
<li><b>VBO did NOT create the cube geometry!</b></li>
<li>- VBO just <b>stored</b> the geometry you created</li>
<li>- It's like uploading a file to cloud storage - the cloud didn't create the file!</li>
</ul>
<ul>
<li>### What OpenGL VAO Does (Format Description)</li>
</ul>
<ul>
<li><b>VAO (Vertex Array Object)</b> describes the <b>format</b> of data in the VBO.</li>
<li>It's like a "schema" or "struct definition" for the vertex data.</li>
</ul>
<ul>
<li>```cpp</li>
<li>// Create a VAO (format descriptor)</li>
<li>GLuint vao;</li>
<li>glGenVertexArrays(1, &amp;vao); // GPU: "I created format descriptor ID 7"</li>
<li>glBindVertexArray(vao); // GPU: "Format 7 is now active"</li>
</ul>
<ul>
<li>// Tell OpenGL how to INTERPRET the data in VBO</li>
<li>// Position attribute (first 3 floats of each vertex)</li>
<li>glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);</li>
<li>// ^ ^ ^^^^^^^^^^^^^^^^^^ ^^^^^^^^^^</li>
<li>// | | | Offset = 0</li>
<li>// | | Stride = 6 floats per vertex</li>
<li>// | Size = 3 components (x, y, z)</li>
<li>// Location = 0 (matches shader "layout(location=0)")</li>
</ul>
<ul>
<li>glEnableVertexAttribArray(0);</li>
</ul>
<ul>
<li>// Color attribute (next 3 floats of each vertex)</li>
<li>glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3 * sizeof(float)));</li>
<li>// ^ ^ ^^^^^^^^^^^^^^^^^^^^^^^^</li>
<li>// | | Offset = 3 floats</li>
<li>// | Size = 3 components (r, g, b)</li>
<li>// Location = 1</li>
</ul>
<ul>
<li>glEnableVertexAttribArray(1);</li>
<li>```</li>
</ul>
<ul>
<li><b>VAO is just metadata!</b> It tells the GPU:</li>
<li>- "Attribute 0 is 3 floats starting at offset 0, step forward 6 floats to next vertex"</li>
<li>- "Attribute 1 is 3 floats starting at offset 3, step forward 6 floats to next vertex"</li>
</ul>
<ul>
<li>Think of VBO as a flat array: <code>[x, y, z, r, g, b, x, y, z, r, g, b, ...]</code></li>
</ul>
<ul>
<li>VAO tells the GPU how to parse it: <code>[(x,y,z), (r,g,b)], [(x,y,z), (r,g,b)], ...</code></li>
</ul>
<ul>
<li>### Summary: You Create, OpenGL Stores</li>
</ul>
<ul>
<li>| Component | Role | Analogy |</li>
<li>|--------&mdash;|---&mdash;|------&mdash;|</li>
<li>| <b>Your code</b> | Creates vertex data (geometry) | Chef preparing ingredients |</li>
<li>| <b>VBO</b> | Stores vertex data on GPU | Refrigerator storing ingredients |</li>
<li>| <b>VAO</b> | Describes data format | Recipe card explaining ingredient layout |</li>
<li>| <b>Shader</b> | Processes vertices on GPU | Oven cooking the food |</li>
<li>| <b>glDrawElements()</b> | Triggers rendering | Serving the dish |</li>
</ul>
<ul>
<li><b>You are the geometry creator!</b> OpenGL is just the storage and processing pipeline.</li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## ImGui: Dynamic Geometry Generator</li>
</ul>
<ul>
<li>Now here's where ImGui is different from our cube:</li>
</ul>
<ul>
<li>### Our Cube (Static Geometry)</li>
</ul>
<ul>
<li>```cpp</li>
<li>// We create geometry ONCE in init()</li>
<li>float vertices[] = { /* 36 vertices for a cube */ };</li>
<li>glBufferData(..., vertices, GL_STATIC_DRAW); // Upload once</li>
</ul>
<ul>
<li>// Every frame: just draw the SAME geometry</li>
<li>glDrawElements(...); // Same cube, maybe rotated via uniforms</li>
<li>```</li>
</ul>
<ul>
<li>### ImGui (Dynamic Geometry)</li>
</ul>
<ul>
<li>```cpp</li>
<li>// EVERY FRAME, ImGui creates NEW geometry based on UI state</li>
<li>void MyPanel::draw() {</li>
<li>if (ImGui::Button("Start")) { /* ... */ } // Button state might change!</li>
<li>ImGui::Text("FPS: %d", fps); // Text changes every frame!</li>
<li>}</li>
</ul>
<ul>
<li>// Internally, ImGui generates NEW vertices every frame:</li>
<li>// Frame 1: "FPS: 60" → 24 vertices for text</li>
<li>// Frame 2: "FPS: 59" → 24 vertices for text (different positions!)</li>
<li>// Frame 3: "FPS: 61" → 24 vertices for text (different positions!)</li>
<li>```</li>
</ul>
<ul>
<li><b>Why does ImGui generate new geometry every frame?</b></li>
</ul>
<ul>
<li>Because the UI is <b>dynamic</b>:</li>
<li>- Text content changes ("FPS: 60" → "FPS: 59")</li>
<li>- Button states change (normal → hovered → pressed)</li>
<li>- Windows can be moved, resized, opened, closed</li>
<li>- New panels can appear</li>
</ul>
<ul>
<li>ImGui recalculates the ENTIRE UI layout and generates fresh vertex data every frame!</li>
</ul>
<ul>
<li>### ImGui's OpenGL Backend: The Glue</li>
</ul>
<ul>
<li><b>File</b>: <code>external/imgui/backends/imgui_impl_opengl3.cpp</code></li>
</ul>
<ul>
<li>This is the bridge between ImGui (geometry generator) and OpenGL (storage/renderer):</li>
</ul>
<ul>
<li>```cpp</li>
<li>void ImGui_ImplOpenGL3_RenderDrawData(ImDrawData* draw_data) {</li>
<li>// draw_data contains ImGui's vertex arrays (created by ImGui!)</li>
</ul>
<ul>
<li>for (int n = 0; n &lt; draw_data-&gt;CmdListsCount; n++) {</li>
<li>const ImDrawList* cmd_list = draw_data-&gt;CmdLists[n];</li>
</ul>
<ul>
<li>// Get ImGui's generated vertices</li>
<li>const ImDrawVert* vtx_buffer = cmd_list-&gt;VtxBuffer.Data; // ImGui created this!</li>
<li>const ImDrawIdx* idx_buffer = cmd_list-&gt;IdxBuffer.Data; // ImGui created this!</li>
</ul>
<ul>
<li>// Upload to GPU (EVERY FRAME because vertices change!)</li>
<li>glBufferData(GL_ARRAY_BUFFER,</li>
<li>cmd_list-&gt;VtxBuffer.Size * sizeof(ImDrawVert),</li>
<li>vtx_buffer, // ImGui's vertex data</li>
<li>GL_STREAM_DRAW); // STREAM = changes every frame</li>
</ul>
<ul>
<li>glBufferData(GL_ELEMENT_ARRAY_BUFFER,</li>
<li>cmd_list-&gt;IdxBuffer.Size * sizeof(ImDrawIdx),</li>
<li>idx_buffer, // ImGui's index data</li>
<li>GL_STREAM_DRAW);</li>
</ul>
<ul>
<li>// Draw ImGui's geometry</li>
<li>for (int cmd_i = 0; cmd_i &lt; cmd_list-&gt;CmdBuffer.Size; cmd_i++) {</li>
<li>const ImDrawCmd* pcmd = &amp;cmd_list-&gt;CmdBuffer[cmd_i];</li>
<li>glDrawElements(GL_TRIANGLES, pcmd-&gt;ElemCount, GL_UNSIGNED_SHORT, ...);</li>
<li>}</li>
<li>}</li>
<li>}</li>
<li>```</li>
</ul>
<ul>
<li><b>Flow every frame</b>:</li>
<li>1. ImGui <b>creates</b> vertices for buttons, text, windows (CPU)</li>
<li>2. Backend <b>uploads</b> vertices to VBO via <code>glBufferData()</code> (CPU → GPU)</li>
<li>3. Backend <b>draws</b> vertices via <code>glDrawElements()</code> (GPU execution)</li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## The Complete Picture</li>
</ul>
<ul>
<li>```</li>
<li>┌─────────────────────────────────────────────────────────────────┐</li>
<li>│ WHO CREATES GEOMETRY? │</li>
<li>├─────────────────────────────────────────────────────────────────┤</li>
<li>│ │</li>
<li>│ ┌──────────────────────┐ ┌──────────────────────┐ │</li>
<li>│ │ Our Cube (<a class="el" href="classRenderer.html" title="OpenGL 3.3 renderer for the main 3D scene.">Renderer</a>) │ │ ImGui UI │ │</li>
<li>│ │ │ │ │ │</li>
<li>│ │ WE create geometry: │ │ IMGUI creates geom: │ │</li>
<li>│ │ float vertices[] = │ │ Button() generates │ │</li>
<li>│ │ { -0.5, -0.5, ... } │ │ → 6 vertices │ │</li>
<li>│ │ │ │ Text() generates │ │</li>
<li>│ │ Created ONCE in │ │ → 24 vertices │ │</li>
<li>│ │ init() │ │ │ │</li>
<li>│ │ │ │ Created EVERY frame │ │</li>
<li>│ └──────────┬───────────┘ └──────────┬───────────┘ │</li>
<li>│ │ │ │</li>
<li>│ └────────────┬───────────────────┘ │</li>
<li>│ ▼ │</li>
<li>│ ┌───────────────────────┐ │</li>
<li>│ │ OpenGL (Storage Only) │ │</li>
<li>│ │ │ │</li>
<li>│ │ VBO: Stores vertices │ │</li>
<li>│ │ VAO: Describes format │ │</li>
<li>│ │ Does NOT create geom! │ │</li>
<li>│ └───────────┬───────────┘ │</li>
<li>│ ▼ │</li>
<li>│ ┌───────────────────────┐ │</li>
<li>│ │ GPU (Processes Only) │ │</li>
<li>│ │ │ │</li>
<li>│ │ Shaders: <a class="el" href="classTransform.html">Transform</a> │ │</li>
<li>│ │ vertices │ │</li>
<li>│ │ Does NOT create geom! │ │</li>
<li>│ └───────────────────────┘ │</li>
<li>└─────────────────────────────────────────────────────────────────┘</li>
<li>```</li>
</ul>
<ul>
<li><b>Key insight</b>:</li>
<li>- <b>You (or ImGui)</b> are the geometry creators</li>
<li>- <b>OpenGL</b> is just the delivery system (VBO = storage, VAO = format)</li>
<li>- <b>GPU</b> is just the processor (shaders transform what you created)</li>
</ul>
<ul>
<li>Neither OpenGL nor GPU create geometry - they only store and process what you give them!</li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## The Complete Hardware Pipeline</li>
</ul>
<ul>
<li>Let's trace a single frame from our application through the hardware:</li>
</ul>
<ul>
<li>### Step 1: <a class="el" href="classApplication.html" title="Main application orchestrating the simulation, rendering, and UI.">Application</a> Code (CPU)</li>
</ul>
<ul>
<li><b>File</b>: <code><a class="el" href="application_8cpp.html">src/app/application.cpp</a></code> - <a class="el" href="classApplication.html#af44c742342adf5305e430ff293f147c1" title="Execute one frame: update simulation, render 3D, render UI.">Application::tick()</a></li>
</ul>
<ul>
<li>```cpp</li>
<li>void <a class="el" href="classApplication.html#af44c742342adf5305e430ff293f147c1" title="Execute one frame: update simulation, render 3D, render UI.">Application::tick()</a> {</li>
<li>// This runs on CPU cores</li>
<li>// Data is in system RAM, cached in L1/L2/L3</li>
</ul>
<ul>
<li>for (auto&amp; module : modules) {</li>
<li>module-&gt;update(dt, state); // Update quaternion, sensors, etc.</li>
<li>}</li>
<li>}</li>
<li>```</li>
</ul>
<ul>
<li><b>Hardware view</b>:</li>
<li>```</li>
<li>CPU Core 0:</li>
<li>├─ Fetch instruction from L1 I-cache (32 KB)</li>
<li>├─ Load <a class="el" href="structSimulationState.html" title="Central shared state for the entire simulation.">SimulationState</a> from L1 D-cache (32 KB) or L2 (256 KB) or L3 (8 MB)</li>
<li>├─ Execute quaternion math (FPU/SIMD units)</li>
<li>└─ Write result back to cache, eventually to RAM</li>
<li>```</li>
</ul>
<ul>
<li>At this point, all data is <b>still on the CPU side</b> in system RAM.</li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>### Step 2: Prepare GPU Data (CPU → GPU Transfer)</li>
</ul>
<ul>
<li><b>File</b>: <code><a class="el" href="renderer_8cpp.html">src/render/renderer.cpp</a></code> - <a class="el" href="classRenderer.html#a628ba0693fd83815acac8c69b7dcf9f0" title="Initialize OpenGL resources (shaders, geometry buffers)">Renderer::init()</a></li>
</ul>
<ul>
<li>```cpp</li>
<li>void <a class="el" href="classRenderer.html#a628ba0693fd83815acac8c69b7dcf9f0" title="Initialize OpenGL resources (shaders, geometry buffers)">Renderer::init()</a> {</li>
<li>// CPU: Create vertex data in system RAM</li>
<li>float vertices[] = {</li>
<li>-0.5f, -0.5f, -0.5f, 1.0f, 0.0f, 0.0f, // Red vertex</li>
<li>// ... more vertices</li>
<li>};</li>
</ul>
<ul>
<li>// Generate a buffer ID on the GPU</li>
<li>glGenBuffers(1, &amp;vbo);</li>
</ul>
<ul>
<li>// Bind it as the active buffer</li>
<li>glBindBuffer(GL_ARRAY_BUFFER, vbo);</li>
</ul>
<ul>
<li>// CRITICAL: Transfer data from system RAM to GPU VRAM</li>
<li>glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</li>
<li>// ^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^^^^ ^^^^^^^^</li>
<li>// Target Size Pointer to RAM</li>
<li>}</li>
<li>```</li>
</ul>
<ul>
<li><b>Hardware view (integrated GPU)</b>:</li>
<li>```</li>
<li>1. CPU prepares data in system RAM (CPU-accessible region)</li>
<li>RAM Address 0x7fff1234: [vertex data: -0.5, -0.5, -0.5, 1.0, ...]</li>
</ul>
<ul>
<li>2. glBufferData() triggers memory copy to GPU-accessible region</li>
<li>CPU side of RAM → GPU side of RAM</li>
</ul>
<ul>
<li>Both regions are in the SAME physical RAM chips!</li>
<li>Transfer happens via memory controller on the CPU die.</li>
</ul>
<ul>
<li>3. GPU can now access data in its reserved memory region</li>
<li>RAM Address 0x8000000: [vertex data: -0.5, -0.5, -0.5, 1.0, ...]</li>
</ul>
<ul>
<li>GPU reads from system RAM (not separate VRAM).</li>
<li>Bandwidth: ~50 GB/s shared between CPU and GPU.</li>
<li>```</li>
</ul>
<ul>
<li><b>Why do we still copy?</b></li>
<li>- Even though it's the same RAM, the GPU has a reserved region</li>
<li>- Driver manages memory partitioning</li>
<li>- Copy ensures data is in GPU-optimized layout (cache-friendly)</li>
<li>- Still do it once in init() and reuse every frame!</li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>### Step 3: Upload Per-Frame Data (CPU → GPU Transfer)</li>
</ul>
<ul>
<li><b>File</b>: <code><a class="el" href="renderer_8cpp.html">src/render/renderer.cpp</a></code> - Renderer::draw()</li>
</ul>
<ul>
<li>```cpp</li>
<li>void Renderer::draw(const SimulationState&amp; state) {</li>
<li>// CPU: Read quaternion from system RAM</li>
<li>const auto&amp; q = state.quaternion;</li>
</ul>
<ul>
<li>// CPU: Calculate model matrix (4x4 = 16 floats = 64 bytes)</li>
<li>glm::mat4 model = glm::mat4_cast(q);</li>
</ul>
<ul>
<li>// Upload to GPU uniform (small data, happens every frame)</li>
<li>glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(model));</li>
<li>// ^^^^^^^^ ^ ^^^^^^^^^^^^^^^^^^^^</li>
<li>// Location Count Pointer to CPU data</li>
<li>}</li>
<li>```</li>
</ul>
<ul>
<li><b>Hardware view (integrated GPU)</b>:</li>
<li>```</li>
<li>CPU (L1 cache): model matrix = [1.0, 0.0, 0.0, 0.0, ...]</li>
<li>↓</li>
<li>Copy to GPU region in RAM</li>
<li>↓</li>
<li>GPU memory region: model = [1.0, 0.0, 0.0, 0.0, ...]</li>
<li>↓</li>
<li>GPU reads via memory controller</li>
<li>↓</li>
<li>GPU L3 cache: model matrix cached for shader access</li>
</ul>
<ul>
<li>This happens EVERY frame because the quaternion changes!</li>
<li>But it's only 64 bytes, so it's fast (memory controller handles it).</li>
<li>```</li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>### Step 4: Issue Draw Call (CPU → GPU Command)</li>
</ul>
<ul>
<li><b>File</b>: <code><a class="el" href="renderer_8cpp.html">src/render/renderer.cpp</a></code> - Renderer::draw()</li>
</ul>
<ul>
<li>```cpp</li>
<li>void Renderer::draw(const SimulationState&amp; state) {</li>
<li>// ... setup code ...</li>
</ul>
<ul>
<li>// Send draw command to GPU</li>
<li>glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0);</li>
<li>// ^^^^^^^^^^^^ ^^ ^^^^^^^^^^^^^^^ ^</li>
<li>// Draw triangles| Data type Offset</li>
<li>// Count</li>
<li>}</li>
<li>```</li>
</ul>
<ul>
<li><b>Hardware view</b>:</li>
<li>```</li>
<li>CPU: Writes command to GPU command queue in memory:</li>
<li>Command: DRAW_INDEXED</li>
<li>Mode: TRIANGLES</li>
<li>Count: 36</li>
<li>VBO: [handle to VRAM buffer]</li>
<li>EBO: [handle to VRAM index buffer]</li>
<li>Shader: [handle to compiled shader program]</li>
<li>Uniforms: [pointers to uniform data in VRAM]</li>
</ul>
<ul>
<li>GPU: Reads command from queue (DMA - Direct Memory Access)</li>
<li>"Ah, I need to draw 36 vertices as triangles. Let's go!"</li>
<li>```</li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>### Step 5: GPU Vertex Processing (Parallel)</li>
</ul>
<ul>
<li>The GPU now processes vertices <b>in parallel</b> on thousands of cores.</li>
</ul>
<ul>
<li><b>File</b>: <code>shaders/cube.vert</code> (Vertex Shader)</li>
</ul>
<ul>
<li>```glsl</li>
<li>#version 330 core</li>
<li>layout (location = 0) in vec3 aPos; // Input from VBO</li>
<li>layout (location = 1) in vec3 aColor; // Input from VBO</li>
</ul>
<ul>
<li>uniform mat4 model; // From CPU via glUniformMatrix4fv()</li>
<li>uniform mat4 view;</li>
<li>uniform mat4 proj;</li>
</ul>
<ul>
<li>out vec3 fragColor; // Output to fragment shader</li>
</ul>
<ul>
<li>void <a class="el" href="main_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a> {</li>
<li>// This runs ONCE PER VERTEX on the GPU</li>
<li>gl_Position = proj * view * model * vec4(aPos, 1.0);</li>
<li>fragColor = aColor;</li>
<li>}</li>
<li>```</li>
</ul>
<ul>
<li><b>Hardware view (integrated GPU)</b>:</li>
<li>```</li>
<li>Integrated GPU has 96 execution units (example: Intel UHD Graphics 630)</li>
<li>Each execution unit can handle 7 threads simultaneously.</li>
<li>Total: 96 × 7 = 672 parallel threads</li>
</ul>
<ul>
<li>We have 36 vertices to process.</li>
</ul>
<ul>
<li>Vertex Shader Execution:</li>
<li>EU 0, thread 0: Vertex 0 → position = proj * view * model * (-0.5, -0.5, -0.5)</li>
<li>EU 0, thread 1: Vertex 1 → position = proj * view * model * ( 0.5, -0.5, -0.5)</li>
<li>EU 1, thread 0: Vertex 2 → position = proj * view * model * ( 0.5, 0.5, -0.5)</li>
<li>...</li>
<li>EU 5, thread 1: Vertex 35 → position = proj * view * model * (...)</li>
</ul>
<ul>
<li>All 36 vertices processed in PARALLEL across multiple execution units!</li>
</ul>
<ul>
<li>Each execution unit:</li>
<li>1. Reads vertex position from system RAM (GPU's reserved region)</li>
<li>2. Reads uniform matrices from system RAM (cached in GPU L3)</li>
<li>3. Executes matrix multiplications (GPU ALU - FMA units)</li>
<li>4. Writes output position to internal GPU registers</li>
<li>```</li>
</ul>
<ul>
<li><b>Why is this fast?</b></li>
<li>- GPU has many execution units (96 EUs vs 8 CPU cores)</li>
<li>- Each EU handles 7 threads simultaneously (SIMD architecture)</li>
<li>- All doing the <b>exact same operation</b> (matrix multiply)</li>
<li>- No branching, no complex logic</li>
<li>- Specialized for parallel floating-point math</li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>### Step 6: GPU Rasterization (Fixed Function Hardware)</li>
</ul>
<ul>
<li>After vertex processing, the GPU has a list of triangles in screen space.</li>
</ul>
<ul>
<li><b>Rasterization</b> converts triangles into pixels.</li>
</ul>
<ul>
<li>```</li>
<li>Input: Triangle with vertices at (100, 100), (200, 100), (150, 200)</li>
<li>Output: List of all pixels inside the triangle</li>
</ul>
<ul>
<li>Example: (100, 100), (101, 100), (102, 100), ..., (150, 150), ...</li>
</ul>
<ul>
<li>For a 1920x1080 screen, this might be millions of pixels!</li>
<li>```</li>
</ul>
<ul>
<li><b>Hardware view</b>:</li>
<li>```</li>
<li>GPU Rasterizer (fixed-function unit):</li>
<li>├─ Receives 12 triangles (36 vertices / 3)</li>
<li>├─ For each triangle:</li>
<li>│ ├─ Clip to screen bounds</li>
<li>│ ├─ Find all pixels inside triangle (edge equations)</li>
<li>│ └─ Interpolate vertex attributes (color, UV, etc.)</li>
<li>└─ Output: ~500,000 fragments (pixels) to process</li>
<li>```</li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>### Step 7: GPU Fragment Processing (Parallel)</li>
</ul>
<ul>
<li>For every pixel inside every triangle, run the <b>fragment shader</b>.</li>
</ul>
<ul>
<li><b>File</b>: <code>shaders/cube.frag</code> (Fragment Shader)</li>
</ul>
<ul>
<li>```glsl</li>
<li>#version 330 core</li>
<li>in vec3 fragColor; // Interpolated from vertex shader</li>
<li>out vec4 finalColor; // Output to framebuffer</li>
</ul>
<ul>
<li>void <a class="el" href="main_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a> {</li>
<li>// This runs ONCE PER PIXEL on the GPU</li>
<li>finalColor = vec4(fragColor, 1.0);</li>
<li>}</li>
<li>```</li>
</ul>
<ul>
<li><b>Hardware view (integrated GPU)</b>:</li>
<li>```</li>
<li>Fragment Shader Execution (500,000 pixels):</li>
<li>EU 0, thread 0: Pixel (100, 100) → color = (1.0, 0.0, 0.0, 1.0)</li>
<li>EU 0, thread 1: Pixel (101, 100) → color = (1.0, 0.0, 0.0, 1.0)</li>
<li>EU 0, thread 2: Pixel (102, 100) → color = (0.98, 0.02, 0.0, 1.0) ← interpolated!</li>
<li>...</li>
<li>EU 95, thread 6: Pixel (543, 789) → color = (0.5, 0.5, 0.0, 1.0)</li>
</ul>
<ul>
<li>All running in PARALLEL across 96 execution units × 7 threads each!</li>
</ul>
<ul>
<li>Output goes to Framebuffer in system RAM (GPU's reserved region):</li>
<li>RAM Address 0x80000000: [pixel data: RGBA RGBA RGBA ...]</li>
</ul>
<ul>
<li>Framebuffer is in system RAM, not dedicated VRAM.</li>
<li>```</li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>### Step 8: ImGui Rendering (CPU generates, GPU renders)</li>
</ul>
<ul>
<li><b>File</b>: <code><a class="el" href="telemetry__panel_8cpp.html">src/gui/panels/telemetry_panel.cpp</a></code> - <a class="el" href="classTelemetryPanel.html#abe2679f505e98b764eb45e0d78d6049a" title="Render the panel&#39;s ImGui interface.">TelemetryPanel::draw()</a></li>
</ul>
<ul>
<li>```cpp</li>
<li>void <a class="el" href="classTelemetryPanel.html#abe2679f505e98b764eb45e0d78d6049a" title="Render the panel&#39;s ImGui interface.">TelemetryPanel::draw(SimulationState&amp; state, Camera&amp;)</a> {</li>
<li>// This runs on CPU</li>
<li>ImGui::Begin("Telemetry");</li>
<li>ImGui::Text("Quaternion: %.3f, %.3f, %.3f, %.3f",</li>
<li>state.quaternion.w, state.quaternion.x,</li>
<li>state.quaternion.y, state.quaternion.z);</li>
<li>ImGui::End();</li>
<li>}</li>
<li>```</li>
</ul>
<ul>
<li><b>What happens internally</b>:</li>
</ul>
<ul>
<li>```cpp</li>
<li>// ImGui (CPU side) generates draw commands:</li>
<li>DrawList = [</li>
<li>DrawRect(x: 10, y: 10, w: 300, h: 400, color: 0x000000F0), // Window background</li>
<li>DrawText(x: 20, y: 30, text: "Quaternion: 1.000, 0.000, ...", color: 0xFFFFFFFF),</li>
<li>// ... more draw commands</li>
<li>];</li>
</ul>
<ul>
<li>// Then ImGui_ImplOpenGL3_RenderDrawData() (CPU → GPU):</li>
<li>for (cmd in DrawList) {</li>
<li>// Upload vertex data to GPU</li>
<li>glBufferData(GL_ARRAY_BUFFER, cmd.vertices, GL_STREAM_DRAW);</li>
</ul>
<ul>
<li>// Draw</li>
<li>glDrawElements(GL_TRIANGLES, cmd.count, ...);</li>
<li>}</li>
<li>```</li>
</ul>
<ul>
<li><b>Hardware view</b>:</li>
<li>```</li>
<li>CPU:</li>
<li>├─ ImGui calculates layout (system RAM)</li>
<li>├─ Generates vertex data: rectangles as triangles</li>
<li>│ Text "Q" → 2 triangles (using font texture)</li>
<li>│ Window background → 2 triangles</li>
<li>└─ Sends to GPU via OpenGL</li>
</ul>
<ul>
<li>GPU:</li>
<li>├─ Vertex shader: <a class="el" href="classTransform.html">Transform</a> UI vertices to screen space</li>
<li>├─ Fragment shader: Sample font texture, output pixel color</li>
<li>└─ Write to framebuffer on top of 3D scene</li>
<li>```</li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>### Step 9: Display to Screen (GPU → Monitor)</li>
</ul>
<ul>
<li><b>File</b>: <code><a class="el" href="application_8cpp.html">src/app/application.cpp</a></code> - <a class="el" href="classApplication.html#af44c742342adf5305e430ff293f147c1" title="Execute one frame: update simulation, render 3D, render UI.">Application::tick()</a></li>
</ul>
<ul>
<li>```cpp</li>
<li>void <a class="el" href="classApplication.html#af44c742342adf5305e430ff293f147c1" title="Execute one frame: update simulation, render 3D, render UI.">Application::tick()</a> {</li>
<li>// ... render 3D ...</li>
<li>// ... render UI ...</li>
</ul>
<ul>
<li>// Swap front and back buffers</li>
<li>glfwSwapBuffers(window);</li>
<li>}</li>
<li>```</li>
</ul>
<ul>
<li><b>Hardware view (integrated GPU)</b>:</li>
<li>```</li>
<li>GPU has TWO framebuffers in system RAM:</li>
<li>├─ Front buffer: Currently being scanned out to monitor</li>
<li>└─ Back buffer: Currently being rendered to</li>
</ul>
<ul>
<li>glfwSwapBuffers():</li>
<li>├─ Wait for V-Sync (monitor refresh, 60 Hz = 16.67ms)</li>
<li>├─ Swap pointers: back ↔ front (just pointer swap, no data copy!)</li>
<li>└─ Display engine now scans out from new front buffer</li>
</ul>
<ul>
<li>Display Engine (on CPU die):</li>
<li>├─ Reads pixel data from front buffer in system RAM</li>
<li>│ Via memory controller (shared with CPU/GPU memory access)</li>
<li>├─ Converts to display signal (DisplayPort/HDMI)</li>
<li>└─ Sends to monitor</li>
</ul>
<ul>
<li>Monitor:</li>
<li>├─ Receives digital signal (DisplayPort/HDMI)</li>
<li>└─ Updates physical pixels on screen (LCD backlight, LED, OLED)</li>
</ul>
<ul>
<li>Refresh rate: 60 Hz = scan 1920×1080 pixels 60 times per second</li>
<li>Bandwidth needed: 1920 × 1080 × 4 bytes × 60 Hz = ~500 MB/s from RAM</li>
<li>```</li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## Summary: The Complete Journey</li>
</ul>
<ul>
<li>```</li>
<li>┌─────────────────────────────────────────────────────────────────┐</li>
<li>│ CPU Die (Intel/AMD with integrated graphics) │</li>
<li>│ │</li>
<li>│ ┌──────────────────────┐ ┌──────────────────────┐ │</li>
<li>│ │ CPU Cores (8 cores) │ │ iGPU (96 EUs) │ │</li>
<li>│ │ ├─ Your C++ code │ │ ├─ Vertex Shader │ │</li>
<li>│ │ ├─ ImGui logic │ │ ├─ Rasterizer │ │</li>
<li>│ │ └─ OpenGL API calls │ │ └─ Fragment Shader │ │</li>
<li>│ └──────────┬───────────┘ └──────────┬───────────┘ │</li>
<li>│ │ │ │</li>
<li>│ └────────────┬───────────────────┘ │</li>
<li>│ │ │</li>
<li>│ ┌───────▼────────┐ │</li>
<li>│ │ Memory │ │</li>
<li>│ │ Controller │ │</li>
<li>│ └───────┬────────┘ │</li>
<li>└──────────────────────────┼──────────────────────────────────────┘</li>
<li>│</li>
<li>┌────────▼────────┐</li>
<li>│ System RAM │ 16 GB DDR4 (~50 GB/s)</li>
<li>│ ├─ CPU region │ 14 GB for applications</li>
<li>│ ├─ GPU region │ 2 GB reserved for graphics</li>
<li>│ └─ Framebuffer │ 1920×1080×4×2 = 16 MB</li>
<li>└────────┬────────┘</li>
<li>│</li>
<li>┌────────▼────────┐</li>
<li>│ Display Engine │ (on CPU die)</li>
<li>│ Reads from RAM │</li>
<li>└────────┬────────┘</li>
<li>│ DisplayPort/HDMI</li>
<li>↓</li>
<li>┌─────────────────┐</li>
<li>│ Monitor (60 Hz) │</li>
<li>└─────────────────┘</li>
<li>```</li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## Key Takeaways</li>
</ul>
<ul>
<li>1. <b>Integrated GPU: Two processors on one die</b></li>
<li>- CPU cores and GPU execution units share the same chip</li>
<li>- Both access the same system RAM (no separate VRAM)</li>
<li>- Memory is partitioned by the driver</li>
<li>- Data still needs to be copied to GPU-accessible region</li>
</ul>
<ul>
<li>2. <b>OpenGL is a command API, not a library</b></li>
<li>- Queues commands for the GPU driver</li>
<li>- Driver translates to GPU-specific machine code</li>
<li>- Execution happens asynchronously on GPU execution units</li>
</ul>
<ul>
<li>3. <b>ImGui is a CPU library</b></li>
<li>- Runs 100% on CPU cores</li>
<li>- Generates vertex data and draw commands</li>
<li>- Needs a backend (imgui_impl_opengl3.cpp) to render via OpenGL</li>
</ul>
<ul>
<li>4. <b>Shaders are GPU programs</b></li>
<li>- Written in GLSL (OpenGL Shading Language)</li>
<li>- Compiled by driver to GPU machine code</li>
<li>- Run in parallel across execution units (96 EUs × 7 threads = 672 parallel)</li>
</ul>
<ul>
<li>5. <b>Memory and bandwidth matter</b></li>
<li>- System RAM bandwidth: ~50 GB/s (shared between CPU and GPU!)</li>
<li>- GPU execution units: 96 EUs with SIMD (good for parallel math)</li>
<li>- Memory controller coordinates CPU, GPU, and display engine access</li>
<li>- Upload once in init(), reuse every frame to minimize transfers</li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## Mental Model</li>
</ul>
<ul>
<li>Think of it like a restaurant:</li>
</ul>
<ul>
<li>- <b>You (application code)</b>: Customer placing an order</li>
<li>- <b>OpenGL</b>: Waiter taking your order to the kitchen</li>
<li>- <b>GPU Driver</b>: Kitchen manager organizing cooks</li>
<li>- <b>GPU</b>: Kitchen with 2560 cooks working in parallel</li>
<li>- <b>VRAM</b>: Kitchen's ingredient storage (fast access)</li>
<li>- <b>System RAM</b>: Grocery store (slower, must transport ingredients)</li>
<li>- <b>Monitor</b>: Serving the finished dish to the customer</li>
</ul>
<ul>
<li>You don't cook the food yourself - you describe what you want,</li>
<li>and the kitchen (GPU) does the actual work in parallel!</li>
</ul>
<ul>
<li>&mdash;</li>
</ul>
<ul>
<li>## See Also</li>
</ul>
<ul>
<li>- <a class="el" href="opengl_tutorial.html">OpenGL Deep Dive Tutorial</a> - OpenGL concepts in detail</li>
<li>- <a class="el" href="imgui_tutorial.html">ImGui Deep Dive Tutorial</a> - ImGui immediate mode GUI</li>
<li>- <a class="el" href="opengl_imgui_integration.html">OpenGL + ImGui Integration</a> - How they work together</li>
<li>- <a class="el" href="architecture.html">Complete System Architecture</a> - Overall application architecture */ </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
