<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AeroDynControlRig: OpenGL Deep Dive Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AeroDynControlRig
   </div>
   <div id="projectbrief">Flight control algorithm testbed with OpenGL 3D visualization and ImGui dashboard</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('opengl_tutorial.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">OpenGL Deep Dive Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md330">OpenGL Deep Dive Tutorial</a><ul><li class="level2"><a href="#autotoc_md331">What is OpenGL?</a><ul><li class="level3"><a href="#autotoc_md332">Why Use OpenGL?</a></li>
<li class="level3"><a href="#autotoc_md333">OpenGL in Our Application</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md335">The Mental Model: CPU ↔ GPU Pipeline</a></li>
<li class="level2"><a href="#autotoc_md337">Core Concept 1: Vertices</a><ul><li class="level3"><a href="#autotoc_md338">What is a Vertex?</a></li>
<li class="level3"><a href="#autotoc_md339">Example from &lt;tt&gt;renderer.cpp&lt;/tt&gt;</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md341">Core Concept 2: VBO (Vertex Buffer Object)</a><ul><li class="level3"><a href="#autotoc_md342">What is a VBO?</a></li>
<li class="level3"><a href="#autotoc_md343">Why Use VBOs?</a></li>
<li class="level3"><a href="#autotoc_md344">Creating a VBO in Our Code</a></li>
<li class="level3"><a href="#autotoc_md345">Buffer Usage Hints</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md347">Core Concept 3: VAO (Vertex Array Object)</a><ul><li class="level3"><a href="#autotoc_md348">What is a VAO?</a></li>
<li class="level3"><a href="#autotoc_md349">Analogy</a></li>
<li class="level3"><a href="#autotoc_md350">Creating a VAO in Our Code</a></li>
<li class="level3"><a href="#autotoc_md351">Understanding Stride and Offset</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md353">Core Concept 4: EBO (Element Buffer Object)</a><ul><li class="level3"><a href="#autotoc_md354">What is an EBO?</a></li>
<li class="level3"><a href="#autotoc_md355">The Problem: Duplicate Vertices</a></li>
<li class="level3"><a href="#autotoc_md356">The Solution: Indexed Drawing</a></li>
<li class="level3"><a href="#autotoc_md357">Creating an EBO</a></li>
<li class="level3"><a href="#autotoc_md358">Drawing with Indices</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md360">Core Concept 5: Shaders</a><ul><li class="level3"><a href="#autotoc_md361">What are Shaders?</a></li>
<li class="level3"><a href="#autotoc_md362">Two Required Shaders</a></li>
<li class="level3"><a href="#autotoc_md363">Vertex Shader Example (from &lt;tt&gt;shaders/vertex_shader.glsl&lt;/tt&gt;)</a></li>
<li class="level3"><a href="#autotoc_md364">Fragment Shader Example (from &lt;tt&gt;shaders/fragment_shader.glsl&lt;/tt&gt;)</a></li>
<li class="level3"><a href="#autotoc_md365">Compiling Shaders in C++</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md367">Core Concept 6: Uniforms</a><ul><li class="level3"><a href="#autotoc_md368">What are Uniforms?</a></li>
<li class="level3"><a href="#autotoc_md369">Setting Uniforms in Our Code</a></li>
<li class="level3"><a href="#autotoc_md370">Uniform Types</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md372">Core Concept 7: Coordinate Transformations</a><ul><li class="level3"><a href="#autotoc_md373">The Four Coordinate Spaces</a></li>
<li class="level3"><a href="#autotoc_md374">1. Local Space (Model Space)</a></li>
<li class="level3"><a href="#autotoc_md375">2. World Space</a></li>
<li class="level3"><a href="#autotoc_md376">3. View Space (Camera Space)</a></li>
<li class="level3"><a href="#autotoc_md377">4. Clip Space (NDC - Normalized Device Coordinates)</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md379">Core Concept 8: FBO (Framebuffer Object)</a><ul><li class="level3"><a href="#autotoc_md380">What is an FBO?</a></li>
<li class="level3"><a href="#autotoc_md381">Why Use FBOs?</a></li>
<li class="level3"><a href="#autotoc_md382">Creating an FBO in Our Code</a></li>
<li class="level3"><a href="#autotoc_md383">Rendering to an FBO</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md385">Complete Rendering Loop</a></li>
<li class="level2"><a href="#autotoc_md387">Common Pitfalls and Solutions</a><ul><li class="level3"><a href="#autotoc_md388">Problem: Black Screen</a></li>
<li class="level3"><a href="#autotoc_md389">Problem: Vertices in Wrong Position</a></li>
<li class="level3"><a href="#autotoc_md390">Problem: Memory Leaks</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md392">Performance Tips</a><ul><li class="level3"><a href="#autotoc_md393">1. Minimize State Changes</a></li>
<li class="level3"><a href="#autotoc_md394">2. Use Instancing for Repeated Objects</a></li>
<li class="level3"><a href="#autotoc_md395">3. Batch Similar Objects</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md397">Debugging Tools</a><ul><li class="level3"><a href="#autotoc_md398">1. glGetError()</a></li>
<li class="level3"><a href="#autotoc_md399">2. Shader Info Log</a></li>
<li class="level3"><a href="#autotoc_md400">3. RenderDoc</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md402">Next Steps</a></li>
<li class="level2"><a href="#autotoc_md403">Resources</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>Complete guide to OpenGL 3.3 Core Profile with examples from our application</p><ul>
<li><ul>
<li>* */</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md330"></a>
OpenGL Deep Dive Tutorial</h1>
<h2><a class="anchor" id="autotoc_md331"></a>
What is OpenGL?</h2>
<p><b>OpenGL (Open Graphics Library)</b> is a cross-platform API for rendering 2D and 3D graphics. Think of it as a translator between your C++ code and your graphics card (GPU).</p>
<h3><a class="anchor" id="autotoc_md332"></a>
Why Use OpenGL?</h3>
<ul>
<li><b>Hardware Acceleration</b>: GPU can process millions of vertices in parallel</li>
<li><b>Cross-Platform</b>: Works on Windows, macOS, Linux</li>
<li><b>Mature</b>: Battle-tested since 1992</li>
<li><b>Well-Documented</b>: Tons of resources and tutorials</li>
</ul>
<h3><a class="anchor" id="autotoc_md333"></a>
OpenGL in Our Application</h3>
<p>We use <b>OpenGL 3.3 Core Profile</b> - a modern version that:</p><ul>
<li>Removes deprecated legacy features</li>
<li>Uses programmable shaders (GLSL)</li>
<li>Requires explicit vertex specification (VAO/VBO)</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md335"></a>
The Mental Model: CPU ↔ GPU Pipeline</h2>
<p>Before diving into code, understand the <b>fundamental concept</b>:</p>
<div class="fragment"><div class="line">┌─────────────────────────────────────────────────────────────┐</div>
<div class="line">│                    YOUR C++ CODE (CPU)                      │</div>
<div class="line">│  1. Prepare vertex data (positions, colors, etc.)          │</div>
<div class="line">│  2. Upload data to GPU memory                              │</div>
<div class="line">│  3. Tell GPU how to interpret the data                     │</div>
<div class="line">│  4. Issue draw command                                     │</div>
<div class="line">└────────────────────┬────────────────────────────────────────┘</div>
<div class="line">                     │</div>
<div class="line">                     ▼ glDrawElements()</div>
<div class="line">┌─────────────────────────────────────────────────────────────┐</div>
<div class="line">│                  GRAPHICS CARD (GPU)                        │</div>
<div class="line">│  5. Vertex Shader: Transform each vertex                   │</div>
<div class="line">│  6. Rasterizer: Generate fragments (potential pixels)      │</div>
<div class="line">│  7. Fragment Shader: Color each fragment                   │</div>
<div class="line">│  8. Write to framebuffer (screen or texture)               │</div>
<div class="line">└─────────────────────────────────────────────────────────────┘</div>
</div><!-- fragment --><p><b>Key Insight</b>: You prepare data once, then the GPU processes it in parallel at incredible speed.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md337"></a>
Core Concept 1: Vertices</h2>
<h3><a class="anchor" id="autotoc_md338"></a>
What is a Vertex?</h3>
<p>A <b>vertex</b> is a point in space with associated data. In our app, each vertex has:</p><ul>
<li><b>Position</b> (x, y, z)</li>
<li><b>Color</b> (r, g, b)</li>
</ul>
<h3><a class="anchor" id="autotoc_md339"></a>
Example from &lt;tt&gt;renderer.cpp&lt;/tt&gt;</h3>
<div class="fragment"><div class="line"><span class="comment">// Define 8 vertices for a cube</span></div>
<div class="line"><span class="comment">// Each vertex: 6 floats (3 for position + 3 for color)</span></div>
<div class="line"><span class="keywordtype">float</span> vertices[] = {</div>
<div class="line">    <span class="comment">// Position          Color</span></div>
<div class="line">    <span class="comment">// x     y     z     r    g    b</span></div>
<div class="line">    -0.5f, -0.5f, -0.5f, 1.0f, 0.0f, 0.0f,  <span class="comment">// Vertex 0: Red</span></div>
<div class="line">     0.5f, -0.5f, -0.5f, 0.0f, 1.0f, 0.0f,  <span class="comment">// Vertex 1: Green</span></div>
<div class="line">     0.5f,  0.5f, -0.5f, 0.0f, 0.0f, 1.0f,  <span class="comment">// Vertex 2: Blue</span></div>
<div class="line">    -0.5f,  0.5f, -0.5f, 1.0f, 1.0f, 0.0f,  <span class="comment">// Vertex 3: Yellow</span></div>
<div class="line">    <span class="comment">// ... 4 more vertices for the back face</span></div>
<div class="line">};</div>
</div><!-- fragment --><p><b>Why floats?</b> GPUs work with floating-point numbers. Coordinates are typically in range [-1, 1] for normalized device coordinates (NDC).</p>
<hr  />
<h2><a class="anchor" id="autotoc_md341"></a>
Core Concept 2: VBO (Vertex Buffer Object)</h2>
<h3><a class="anchor" id="autotoc_md342"></a>
What is a VBO?</h3>
<p>A <b>VBO</b> is a chunk of GPU memory that stores vertex data. Think of it as an array on the graphics card.</p>
<h3><a class="anchor" id="autotoc_md343"></a>
Why Use VBOs?</h3>
<ul>
<li><b>Performance</b>: Data stays on GPU (no CPU→GPU transfer every frame)</li>
<li><b>Efficiency</b>: GPU can access data instantly</li>
</ul>
<h3><a class="anchor" id="autotoc_md344"></a>
Creating a VBO in Our Code</h3>
<div class="fragment"><div class="line"><span class="comment">// From renderer.cpp setupCubeGeometry3D()</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Step 1: Generate a buffer ID</span></div>
<div class="line">GLuint vbo;</div>
<div class="line">glGenBuffers(1, &amp;vbo);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Step 2: Bind it (make it &quot;active&quot;)</span></div>
<div class="line">glBindBuffer(GL_ARRAY_BUFFER, vbo);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Step 3: Upload vertex data to GPU</span></div>
<div class="line">glBufferData(</div>
<div class="line">    GL_ARRAY_BUFFER,           <span class="comment">// Target: array buffer</span></div>
<div class="line">    <span class="keyword">sizeof</span>(vertices),          <span class="comment">// Size in bytes</span></div>
<div class="line">    vertices,                  <span class="comment">// Pointer to data</span></div>
<div class="line">    GL_STATIC_DRAW             <span class="comment">// Usage hint: data won&#39;t change</span></div>
<div class="line">);</div>
</div><!-- fragment --><p><b>Think of binding like selecting a tool</b>: You "bind" (select) a VBO before operating on it.</p>
<h3><a class="anchor" id="autotoc_md345"></a>
Buffer Usage Hints</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Hint   </th><th class="markdownTableHeadNone">Meaning   </th><th class="markdownTableHeadNone">Use When    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>GL_STATIC_DRAW</code>   </td><td class="markdownTableBodyNone">Data set once, used many times   </td><td class="markdownTableBodyNone">Geometry that doesn't change (our cube)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>GL_DYNAMIC_DRAW</code>   </td><td class="markdownTableBodyNone">Data changes occasionally   </td><td class="markdownTableBodyNone">Updated every few frames    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>GL_STREAM_DRAW</code>   </td><td class="markdownTableBodyNone">Data changes every frame   </td><td class="markdownTableBodyNone">Particle systems, dynamic meshes   </td></tr>
</table>
<hr  />
<h2><a class="anchor" id="autotoc_md347"></a>
Core Concept 3: VAO (Vertex Array Object)</h2>
<h3><a class="anchor" id="autotoc_md348"></a>
What is a VAO?</h3>
<p>A <b>VAO</b> stores the <b>format</b> of your vertex data. It remembers:</p><ul>
<li>Which VBO to use</li>
<li>How data is laid out (stride, offset)</li>
<li>Which attributes are enabled</li>
</ul>
<h3><a class="anchor" id="autotoc_md349"></a>
Analogy</h3>
<ul>
<li><b>VBO</b> = A filing cabinet (stores the data)</li>
<li><b>VAO</b> = An index card (tells you how files are organized)</li>
</ul>
<h3><a class="anchor" id="autotoc_md350"></a>
Creating a VAO in Our Code</h3>
<div class="fragment"><div class="line"><span class="comment">// From renderer.cpp setupCubeGeometry3D()</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Step 1: Generate VAO</span></div>
<div class="line">GLuint vao;</div>
<div class="line">glGenVertexArrays(1, &amp;vao);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Step 2: Bind it (make it active)</span></div>
<div class="line">glBindVertexArray(vao);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Step 3: Tell OpenGL how data is laid out</span></div>
<div class="line"><span class="comment">// (Must be done AFTER binding VBO)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Attribute 0: Position (3 floats)</span></div>
<div class="line">glVertexAttribPointer(</div>
<div class="line">    0,                          <span class="comment">// Attribute index (matches shader layout location)</span></div>
<div class="line">    3,                          <span class="comment">// Number of components (x, y, z)</span></div>
<div class="line">    GL_FLOAT,                   <span class="comment">// Data type</span></div>
<div class="line">    GL_FALSE,                   <span class="comment">// Normalized? (No)</span></div>
<div class="line">    6 * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>),          <span class="comment">// Stride: bytes between consecutive vertices</span></div>
<div class="line">    (<span class="keywordtype">void</span>*)0                    <span class="comment">// Offset: bytes from start to this attribute</span></div>
<div class="line">);</div>
<div class="line">glEnableVertexAttribArray(0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Attribute 1: Color (3 floats)</span></div>
<div class="line">glVertexAttribPointer(</div>
<div class="line">    1,                          <span class="comment">// Attribute index</span></div>
<div class="line">    3,                          <span class="comment">// Number of components (r, g, b)</span></div>
<div class="line">    GL_FLOAT,                   <span class="comment">// Data type</span></div>
<div class="line">    GL_FALSE,                   <span class="comment">// Normalized? (No)</span></div>
<div class="line">    6 * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>),          <span class="comment">// Stride: same as above</span></div>
<div class="line">    (<span class="keywordtype">void</span>*)(3 * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>))  <span class="comment">// Offset: skip 3 floats (position)</span></div>
<div class="line">);</div>
<div class="line">glEnableVertexAttribArray(1);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md351"></a>
Understanding Stride and Offset</h3>
<p>Our vertex data layout: </p><div class="fragment"><div class="line">[x, y, z, r, g, b] [x, y, z, r, g, b] [x, y, z, r, g, b] ...</div>
<div class="line"> \_____/  \_____/</div>
<div class="line">Position  Color</div>
</div><!-- fragment --><ul>
<li><b>Stride</b>: 6 floats (distance from one vertex to the next)</li>
<li><b>Position offset</b>: 0 (starts at beginning)</li>
<li><b>Color offset</b>: 3 floats (skip position to get to color)</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md353"></a>
Core Concept 4: EBO (Element Buffer Object)</h2>
<h3><a class="anchor" id="autotoc_md354"></a>
What is an EBO?</h3>
<p>An <b>EBO</b> (or <b>IBO</b> - Index Buffer Object) stores <b>indices</b> that reference vertices, avoiding duplication.</p>
<h3><a class="anchor" id="autotoc_md355"></a>
The Problem: Duplicate Vertices</h3>
<p>A cube has 6 faces. Each face has 2 triangles. That's 12 triangles × 3 vertices = <b>36 vertices</b>.</p>
<p>But a cube only has <b>8 unique corners</b>! We're duplicating data.</p>
<h3><a class="anchor" id="autotoc_md356"></a>
The Solution: Indexed Drawing</h3>
<div class="fragment"><div class="line"><span class="comment">// From renderer.cpp</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Instead of storing 36 vertices, store 8 unique ones</span></div>
<div class="line"><span class="keywordtype">float</span> vertices[8 * 6] = { <span class="comment">/* ... */</span> };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Then define triangles using indices</span></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> indices[] = {</div>
<div class="line">    <span class="comment">// Front face</span></div>
<div class="line">    0, 1, 2,    <span class="comment">// Triangle 1</span></div>
<div class="line">    2, 3, 0,    <span class="comment">// Triangle 2</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Back face</span></div>
<div class="line">    4, 5, 6,    <span class="comment">// Triangle 3</span></div>
<div class="line">    6, 7, 4,    <span class="comment">// Triangle 4</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ... more faces</span></div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md357"></a>
Creating an EBO</h3>
<div class="fragment"><div class="line">GLuint ebo;</div>
<div class="line">glGenBuffers(1, &amp;ebo);</div>
<div class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo);</div>
<div class="line">glBufferData(</div>
<div class="line">    GL_ELEMENT_ARRAY_BUFFER,</div>
<div class="line">    <span class="keyword">sizeof</span>(indices),</div>
<div class="line">    indices,</div>
<div class="line">    GL_STATIC_DRAW</div>
<div class="line">);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md358"></a>
Drawing with Indices</h3>
<div class="fragment"><div class="line"><span class="comment">// Instead of:</span></div>
<div class="line"><span class="comment">// glDrawArrays(GL_TRIANGLES, 0, 36);  // Draw 36 vertices</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use:</span></div>
<div class="line">glDrawElements(</div>
<div class="line">    GL_TRIANGLES,      <span class="comment">// Mode</span></div>
<div class="line">    36,                <span class="comment">// Count (number of indices)</span></div>
<div class="line">    GL_UNSIGNED_INT,   <span class="comment">// Index type</span></div>
<div class="line">    0                  <span class="comment">// Offset in EBO</span></div>
<div class="line">);</div>
</div><!-- fragment --><p><b>Benefit</b>: 8 vertices instead of 36! Saves memory and bandwidth.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md360"></a>
Core Concept 5: Shaders</h2>
<h3><a class="anchor" id="autotoc_md361"></a>
What are Shaders?</h3>
<p><b>Shaders</b> are programs that run <b>on the GPU</b>. Written in <b>GLSL</b> (OpenGL Shading Language), they look like C.</p>
<h3><a class="anchor" id="autotoc_md362"></a>
Two Required Shaders</h3>
<ol type="1">
<li><b>Vertex Shader</b>: Runs once per vertex (transforms position)</li>
<li><b>Fragment Shader</b>: Runs once per fragment/pixel (determines color)</li>
</ol>
<h3><a class="anchor" id="autotoc_md363"></a>
Vertex Shader Example (from &lt;tt&gt;shaders/vertex_shader.glsl&lt;/tt&gt;)</h3>
<div class="fragment"><div class="line">#version 330 core</div>
<div class="line"> </div>
<div class="line">// Input: per-vertex data (from VAO)</div>
<div class="line">layout (location = 0) in vec3 aPos;    // Position</div>
<div class="line">layout (location = 1) in vec3 aColor;  // Color</div>
<div class="line"> </div>
<div class="line">// Output: data passed to fragment shader</div>
<div class="line">out vec3 ourColor;</div>
<div class="line"> </div>
<div class="line">// Uniforms: data shared across all vertices</div>
<div class="line">uniform mat4 model;        // Object → World transform</div>
<div class="line">uniform mat4 view;         // World → Camera transform</div>
<div class="line">uniform mat4 projection;   // Camera → Screen transform</div>
<div class="line"> </div>
<div class="line">void main() {</div>
<div class="line">    // Transform vertex position through all matrices</div>
<div class="line">    gl_Position = projection * view * model * vec4(aPos, 1.0);</div>
<div class="line"> </div>
<div class="line">    // Pass color to fragment shader</div>
<div class="line">    ourColor = aColor;</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Key Points</b>:</p><ul>
<li><code>layout (location = X)</code>: Matches <code>glVertexAttribPointer</code> index</li>
<li><code>uniform</code>: Set from C++ code, same for all vertices</li>
<li><code>gl_Position</code>: Built-in output (final vertex position)</li>
</ul>
<h3><a class="anchor" id="autotoc_md364"></a>
Fragment Shader Example (from &lt;tt&gt;shaders/fragment_shader.glsl&lt;/tt&gt;)</h3>
<div class="fragment"><div class="line">#version 330 core</div>
<div class="line"> </div>
<div class="line">// Input: from vertex shader (interpolated)</div>
<div class="line">in vec3 ourColor;</div>
<div class="line"> </div>
<div class="line">// Output: final pixel color</div>
<div class="line">out vec4 FragColor;</div>
<div class="line"> </div>
<div class="line">void main() {</div>
<div class="line">    FragColor = vec4(ourColor, 1.0);  // RGB + Alpha</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Interpolation Magic</b>: If vertex 0 is red and vertex 1 is green, pixels in between smoothly blend from red to green!</p>
<h3><a class="anchor" id="autotoc_md365"></a>
Compiling Shaders in C++</h3>
<div class="fragment"><div class="line"><span class="comment">// From renderer.cpp loadShader()</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Step 1: Create shader objects</span></div>
<div class="line">GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER);</div>
<div class="line">GLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Step 2: Attach source code</span></div>
<div class="line">glShaderSource(vertexShader, 1, &amp;vertexSource, NULL);</div>
<div class="line">glShaderSource(fragmentShader, 1, &amp;fragmentSource, NULL);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Step 3: Compile</span></div>
<div class="line">glCompileShader(vertexShader);</div>
<div class="line">glCompileShader(fragmentShader);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Step 4: Check for errors</span></div>
<div class="line">GLint success;</div>
<div class="line">glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</div>
<div class="line"><span class="keywordflow">if</span> (!success) {</div>
<div class="line">    <span class="keywordtype">char</span> infoLog[512];</div>
<div class="line">    glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Vertex shader compilation failed:\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Step 5: Link into program</span></div>
<div class="line">GLuint shaderProgram = glCreateProgram();</div>
<div class="line">glAttachShader(shaderProgram, vertexShader);</div>
<div class="line">glAttachShader(shaderProgram, fragmentShader);</div>
<div class="line">glLinkProgram(shaderProgram);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Step 6: Clean up (shaders no longer needed after linking)</span></div>
<div class="line">glDeleteShader(vertexShader);</div>
<div class="line">glDeleteShader(fragmentShader);</div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="autotoc_md367"></a>
Core Concept 6: Uniforms</h2>
<h3><a class="anchor" id="autotoc_md368"></a>
What are Uniforms?</h3>
<p><b>Uniforms</b> are variables in shaders that:</p><ul>
<li>Are set from C++ code</li>
<li>Remain constant for an entire draw call</li>
<li>Can be accessed by all vertices/fragments</li>
</ul>
<h3><a class="anchor" id="autotoc_md369"></a>
Setting Uniforms in Our Code</h3>
<div class="fragment"><div class="line"><span class="comment">// From renderer.cpp renderFrame3D()</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Step 1: Get uniform location</span></div>
<div class="line">GLint modelLoc = glGetUniformLocation(shaderProgram, <span class="stringliteral">&quot;model&quot;</span>);</div>
<div class="line">GLint viewLoc = glGetUniformLocation(shaderProgram, <span class="stringliteral">&quot;view&quot;</span>);</div>
<div class="line">GLint projLoc = glGetUniformLocation(shaderProgram, <span class="stringliteral">&quot;projection&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Step 2: Set uniform values (before drawing)</span></div>
<div class="line">glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(modelMatrix));</div>
<div class="line">glUniformMatrix4fv(viewLoc, 1, GL_FALSE, glm::value_ptr(viewMatrix));</div>
<div class="line">glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(projMatrix));</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md370"></a>
Uniform Types</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">C++ Function   </th><th class="markdownTableHeadNone">GLSL Type   </th><th class="markdownTableHeadNone">Use Case    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>glUniform1f()</code>   </td><td class="markdownTableBodyNone"><code>float</code>   </td><td class="markdownTableBodyNone">Single float value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>glUniform3f()</code>   </td><td class="markdownTableBodyNone"><code>vec3</code>   </td><td class="markdownTableBodyNone">Position, color (RGB)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>glUniform4f()</code>   </td><td class="markdownTableBodyNone"><code>vec4</code>   </td><td class="markdownTableBodyNone">Color (RGBA)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>glUniformMatrix4fv()</code>   </td><td class="markdownTableBodyNone"><code>mat4</code>   </td><td class="markdownTableBodyNone">Transformation matrices   </td></tr>
</table>
<hr  />
<h2><a class="anchor" id="autotoc_md372"></a>
Core Concept 7: Coordinate Transformations</h2>
<h3><a class="anchor" id="autotoc_md373"></a>
The Four Coordinate Spaces</h3>
<p>Every vertex goes through <b>four transformations</b>:</p>
<div class="fragment"><div class="line">Local Space          World Space         View Space          Clip Space</div>
<div class="line">(Model)              (Scene)             (Camera)            (Screen)</div>
<div class="line"> </div>
<div class="line">  Cube                 Cube                Cube                Screen</div>
<div class="line">┌────────┐          ┌────────┐          ┌────────┐          ┌────────┐</div>
<div class="line">│   /\   │          │   /\   │          │   /\   │          │   /\   │</div>
<div class="line">│  /  \  │  model   │  /  \  │  view    │  /  \  │  proj    │  /  \  │</div>
<div class="line">│ /____\ │  ────►   │ /____\ │  ────►   │ /____\ │  ────►   │ /____\ │</div>
<div class="line">│        │  matrix  │        │  matrix  │        │  matrix  │  -1→+1 │</div>
<div class="line">└────────┘          └────────┘          └────────┘          └────────┘</div>
<div class="line"> </div>
<div class="line">    │                    │                    │                    │</div>
<div class="line">    └────────────────────┴────────────────────┴────────────────────┘</div>
<div class="line">                gl_Position = projection * view * model * localPos</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md374"></a>
1. Local Space (Model Space)</h3>
<p><b>What</b>: Coordinates relative to the object's origin</p>
<p><b>Example</b>: A cube centered at (0, 0, 0) with size 1.0</p>
<div class="fragment"><div class="line"><span class="comment">// Vertex positions are in local space</span></div>
<div class="line">glm::vec3 vertex = glm::vec3(-0.5f, -0.5f, -0.5f);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md375"></a>
2. World Space</h3>
<p><b>What</b>: Coordinates in the global scene</p>
<p><b>How</b>: Apply <b>model matrix</b></p>
<div class="fragment"><div class="line"><span class="comment">// From application.cpp</span></div>
<div class="line"><span class="comment">// The quaternion demo updates this matrix based on attitude</span></div>
<div class="line">glm::mat4 modelMatrix = state.model_matrix;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This matrix might rotate the cube:</span></div>
<div class="line"><span class="comment">// modelMatrix = glm::rotate(mat4(1.0), angle, axis);</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md376"></a>
3. View Space (Camera Space)</h3>
<p><b>What</b>: Coordinates relative to the camera</p>
<p><b>How</b>: Apply <b>view matrix</b></p>
<div class="fragment"><div class="line"><span class="comment">// From camera.cpp</span></div>
<div class="line">glm::mat4 <a class="code" href="classCamera.html#a2f90e661a78172675ca06ea69667b531">Camera::getViewMatrix</a>()<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordflow">return</span> glm::lookAt(</div>
<div class="line">        <a class="code" href="classCamera.html#a04b5db2c530d8630660e8cfb93a4b3b5">position</a>,          <span class="comment">// Camera position</span></div>
<div class="line">        <a class="code" href="classCamera.html#a04b5db2c530d8630660e8cfb93a4b3b5">position</a> + <a class="code" href="classCamera.html#a8847cf29c9c124906ad5d97ecb5c55d1">front</a>,  <span class="comment">// Look-at point</span></div>
<div class="line">        <a class="code" href="classCamera.html#a3fe5f351380fb118ffc600591769f049">up</a>                 <span class="comment">// Up vector</span></div>
<div class="line">    );</div>
<div class="line">}</div>
<div class="ttc" id="aclassCamera_html_a04b5db2c530d8630660e8cfb93a4b3b5"><div class="ttname"><a href="classCamera.html#a04b5db2c530d8630660e8cfb93a4b3b5">Camera::position</a></div><div class="ttdeci">glm::vec3 position</div><div class="ttdoc">Camera position in world space.</div><div class="ttdef"><b>Definition:</b> camera.h:46</div></div>
<div class="ttc" id="aclassCamera_html_a2f90e661a78172675ca06ea69667b531"><div class="ttname"><a href="classCamera.html#a2f90e661a78172675ca06ea69667b531">Camera::getViewMatrix</a></div><div class="ttdeci">glm::mat4 getViewMatrix() const</div><div class="ttdoc">Get the view matrix for rendering.</div><div class="ttdef"><b>Definition:</b> camera.cpp:12</div></div>
<div class="ttc" id="aclassCamera_html_a3fe5f351380fb118ffc600591769f049"><div class="ttname"><a href="classCamera.html#a3fe5f351380fb118ffc600591769f049">Camera::up</a></div><div class="ttdeci">glm::vec3 up</div><div class="ttdoc">Normalized up direction vector (local)</div><div class="ttdef"><b>Definition:</b> camera.h:48</div></div>
<div class="ttc" id="aclassCamera_html_a8847cf29c9c124906ad5d97ecb5c55d1"><div class="ttname"><a href="classCamera.html#a8847cf29c9c124906ad5d97ecb5c55d1">Camera::front</a></div><div class="ttdeci">glm::vec3 front</div><div class="ttdoc">Normalized forward direction vector.</div><div class="ttdef"><b>Definition:</b> camera.h:47</div></div>
</div><!-- fragment --><p><b>Think of it</b>: The world moves opposite to the camera. If camera moves right, world moves left.</p>
<h3><a class="anchor" id="autotoc_md377"></a>
4. Clip Space (NDC - Normalized Device Coordinates)</h3>
<p><b>What</b>: Final coordinates in range [-1, 1] for x, y, z</p>
<p><b>How</b>: Apply <b>projection matrix</b></p>
<div class="fragment"><div class="line"><span class="comment">// From camera.cpp</span></div>
<div class="line">glm::mat4 <a class="code" href="classCamera.html#aa2ed9d27803f5edc824e4afe8cbbbfbc">Camera::getProjectionMatrix</a>(<span class="keywordtype">float</span> aspectRatio)<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordflow">return</span> glm::perspective(</div>
<div class="line">        glm::radians(<a class="code" href="classCamera.html#a21fc9e142b104d8e94126657abaa075f">zoom</a>),  <span class="comment">// Field of view (FOV)</span></div>
<div class="line">        aspectRatio,         <span class="comment">// Width / Height</span></div>
<div class="line">        0.1f,                <span class="comment">// Near clipping plane</span></div>
<div class="line">        100.0f               <span class="comment">// Far clipping plane</span></div>
<div class="line">    );</div>
<div class="line">}</div>
<div class="ttc" id="aclassCamera_html_a21fc9e142b104d8e94126657abaa075f"><div class="ttname"><a href="classCamera.html#a21fc9e142b104d8e94126657abaa075f">Camera::zoom</a></div><div class="ttdeci">float zoom</div><div class="ttdoc">Field of view (degrees), adjusted by scroll.</div><div class="ttdef"><b>Definition:</b> camera.h:56</div></div>
<div class="ttc" id="aclassCamera_html_aa2ed9d27803f5edc824e4afe8cbbbfbc"><div class="ttname"><a href="classCamera.html#aa2ed9d27803f5edc824e4afe8cbbbfbc">Camera::getProjectionMatrix</a></div><div class="ttdeci">glm::mat4 getProjectionMatrix(float aspectRatio) const</div><div class="ttdoc">Get the perspective projection matrix.</div><div class="ttdef"><b>Definition:</b> camera.cpp:16</div></div>
</div><!-- fragment --><p><b>Perspective</b>: Objects farther away appear smaller (realistic)</p>
<p><b>Orthographic</b>: Objects stay same size regardless of distance (CAD, 2D)</p>
<hr  />
<h2><a class="anchor" id="autotoc_md379"></a>
Core Concept 8: FBO (Framebuffer Object)</h2>
<h3><a class="anchor" id="autotoc_md380"></a>
What is an FBO?</h3>
<p>A <b>Framebuffer</b> is the destination for rendering. By default, you render to the screen. An <b>FBO</b> lets you render to a texture instead.</p>
<h3><a class="anchor" id="autotoc_md381"></a>
Why Use FBOs?</h3>
<p>In our application, we:</p><ol type="1">
<li>Render 3D scene to an FBO (off-screen texture)</li>
<li>Display that texture in an ImGui window</li>
<li>Overlay UI on top</li>
</ol>
<p>This allows ImGui and OpenGL rendering to coexist!</p>
<h3><a class="anchor" id="autotoc_md382"></a>
Creating an FBO in Our Code</h3>
<div class="fragment"><div class="line"><span class="comment">// From application.cpp ensureRenderTarget()</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Step 1: Create FBO</span></div>
<div class="line">GLuint fbo;</div>
<div class="line">glGenFramebuffers(1, &amp;fbo);</div>
<div class="line">glBindFramebuffer(GL_FRAMEBUFFER, fbo);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Step 2: Create a texture (color attachment)</span></div>
<div class="line">GLuint renderTexture;</div>
<div class="line">glGenTextures(1, &amp;renderTexture);</div>
<div class="line">glBindTexture(GL_TEXTURE_2D, renderTexture);</div>
<div class="line">glTexImage2D(</div>
<div class="line">    GL_TEXTURE_2D,</div>
<div class="line">    0,                 <span class="comment">// Mipmap level</span></div>
<div class="line">    GL_RGB,            <span class="comment">// Internal format</span></div>
<div class="line">    width, height,     <span class="comment">// Size</span></div>
<div class="line">    0,                 <span class="comment">// Border (must be 0)</span></div>
<div class="line">    GL_RGB,            <span class="comment">// Format</span></div>
<div class="line">    GL_UNSIGNED_BYTE,  <span class="comment">// Type</span></div>
<div class="line">    NULL               <span class="comment">// No initial data</span></div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Step 3: Attach texture to FBO</span></div>
<div class="line">glFramebufferTexture2D(</div>
<div class="line">    GL_FRAMEBUFFER,</div>
<div class="line">    GL_COLOR_ATTACHMENT0,  <span class="comment">// Attachment point</span></div>
<div class="line">    GL_TEXTURE_2D,</div>
<div class="line">    renderTexture,</div>
<div class="line">    0                      <span class="comment">// Mipmap level</span></div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Step 4: Create depth buffer (for 3D depth testing)</span></div>
<div class="line">GLuint depthBuffer;</div>
<div class="line">glGenRenderbuffers(1, &amp;depthBuffer);</div>
<div class="line">glBindRenderbuffer(GL_RENDERBUFFER, depthBuffer);</div>
<div class="line">glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, width, height);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Step 5: Attach depth buffer to FBO</span></div>
<div class="line">glFramebufferRenderbuffer(</div>
<div class="line">    GL_FRAMEBUFFER,</div>
<div class="line">    GL_DEPTH_STENCIL_ATTACHMENT,</div>
<div class="line">    GL_RENDERBUFFER,</div>
<div class="line">    depthBuffer</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Step 6: Check if framebuffer is complete</span></div>
<div class="line"><span class="keywordflow">if</span> (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Framebuffer is not complete!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Step 7: Unbind (switch back to default framebuffer)</span></div>
<div class="line">glBindFramebuffer(GL_FRAMEBUFFER, 0);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md383"></a>
Rendering to an FBO</h3>
<div class="fragment"><div class="line"><span class="comment">// From application.cpp renderSceneToTexture()</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Step 1: Bind FBO (renders go to texture now)</span></div>
<div class="line">glBindFramebuffer(GL_FRAMEBUFFER, fbo);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Step 2: Clear it</span></div>
<div class="line">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Step 3: Render scene</span></div>
<div class="line">renderer.renderFrame3D(transform);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Step 4: Unbind (switch back to screen)</span></div>
<div class="line">glBindFramebuffer(GL_FRAMEBUFFER, 0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Step 5: Use texture in ImGui</span></div>
<div class="line">ImGui::Image((<span class="keywordtype">void</span>*)(intptr_t)renderTexture, ImVec2(800, 600));</div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="autotoc_md385"></a>
Complete Rendering Loop</h2>
<p>Putting it all together, here's what happens every frame in <code><a class="el" href="classApplication.html#af44c742342adf5305e430ff293f147c1" title="Execute one frame: update simulation, render 3D, render UI.">Application::tick()</a></code>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classApplication.html#af44c742342adf5305e430ff293f147c1">Application::tick</a>() {</div>
<div class="line">    <span class="comment">// 1. Update simulation state</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; module : modules) {</div>
<div class="line">        module-&gt;update(dt, simulationState);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 2. Render 3D scene to off-screen texture</span></div>
<div class="line">    glBindFramebuffer(GL_FRAMEBUFFER, fbo);</div>
<div class="line">    glViewport(0, 0, sceneWidth, sceneHeight);</div>
<div class="line">    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 3. Set shader uniforms</span></div>
<div class="line">    renderer.<a class="code" href="classRenderer.html#a5a9884059a536cf621b3fc92bf4922ad">setModelMatrix</a>(glm::value_ptr(simulationState.<a class="code" href="structSimulationState.html#acef78e29043f3602fe7456343636eb07">model_matrix</a>));</div>
<div class="line">    renderer.<a class="code" href="classRenderer.html#a7e13393392708399974fd1c6fcaf56cb">setViewMatrix</a>(<a class="code" href="classApplication.html#a30d655c36d8fdd1158ca0522ce0770cd">camera</a>.<a class="code" href="classCamera.html#a2f90e661a78172675ca06ea69667b531">getViewMatrix</a>());</div>
<div class="line">    renderer.<a class="code" href="classRenderer.html#ae2535387a5c53cb9f04ba2599fe2a1c8">setProjectionMatrix</a>(<a class="code" href="classApplication.html#a30d655c36d8fdd1158ca0522ce0770cd">camera</a>.<a class="code" href="classCamera.html#aa2ed9d27803f5edc824e4afe8cbbbfbc">getProjectionMatrix</a>(aspect));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 4. Draw geometry</span></div>
<div class="line">    renderer.<a class="code" href="classRenderer.html#a5c4417eb759e6322707ee2ab0ecb595f">renderFrame3D</a>(<a class="code" href="classApplication.html#a32eeac4b1ccc4e25034a54214c1df85b">transform</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 5. Unbind FBO (back to screen)</span></div>
<div class="line">    glBindFramebuffer(GL_FRAMEBUFFER, 0);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 6. Render ImGui UI</span></div>
<div class="line">    ImGui::NewFrame();</div>
<div class="line">    ImGui::Begin(<span class="stringliteral">&quot;Viewport&quot;</span>);</div>
<div class="line">    ImGui::Image((<span class="keywordtype">void</span>*)(intptr_t)renderTexture, viewportSize);</div>
<div class="line">    ImGui::End();</div>
<div class="line"> </div>
<div class="line">    panelManager.<a class="code" href="classPanelManager.html#accbb2906139bed93e60a3b7390c43e90">drawAll</a>(simulationState, <a class="code" href="classApplication.html#a30d655c36d8fdd1158ca0522ce0770cd">camera</a>);</div>
<div class="line"> </div>
<div class="line">    ImGui::Render();</div>
<div class="line">    ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 7. Swap buffers (show frame)</span></div>
<div class="line">    glfwSwapBuffers(window);</div>
<div class="line">}</div>
<div class="ttc" id="aclassApplication_html_a30d655c36d8fdd1158ca0522ce0770cd"><div class="ttname"><a href="classApplication.html#a30d655c36d8fdd1158ca0522ce0770cd">Application::camera</a></div><div class="ttdeci">Camera camera</div><div class="ttdoc">3D scene camera</div><div class="ttdef"><b>Definition:</b> application.h:48</div></div>
<div class="ttc" id="aclassApplication_html_a32eeac4b1ccc4e25034a54214c1df85b"><div class="ttname"><a href="classApplication.html#a32eeac4b1ccc4e25034a54214c1df85b">Application::transform</a></div><div class="ttdeci">Transform transform</div><div class="ttdoc">Transformation matrix utilities.</div><div class="ttdef"><b>Definition:</b> application.h:47</div></div>
<div class="ttc" id="aclassApplication_html_af44c742342adf5305e430ff293f147c1"><div class="ttname"><a href="classApplication.html#af44c742342adf5305e430ff293f147c1">Application::tick</a></div><div class="ttdeci">void tick()</div><div class="ttdoc">Execute one frame: update simulation, render 3D, render UI.</div><div class="ttdef"><b>Definition:</b> application.cpp:376</div></div>
<div class="ttc" id="aclassPanelManager_html_accbb2906139bed93e60a3b7390c43e90"><div class="ttname"><a href="classPanelManager.html#accbb2906139bed93e60a3b7390c43e90">PanelManager::drawAll</a></div><div class="ttdeci">void drawAll(SimulationState &amp;state, Camera &amp;camera)</div><div class="ttdoc">Render all registered panels.</div><div class="ttdef"><b>Definition:</b> panel_manager.cpp:10</div></div>
<div class="ttc" id="aclassRenderer_html_a5a9884059a536cf621b3fc92bf4922ad"><div class="ttname"><a href="classRenderer.html#a5a9884059a536cf621b3fc92bf4922ad">Renderer::setModelMatrix</a></div><div class="ttdeci">void setModelMatrix(const float *modelMat)</div><div class="ttdoc">Set the model matrix (object → world transform)</div><div class="ttdef"><b>Definition:</b> renderer.cpp:98</div></div>
<div class="ttc" id="aclassRenderer_html_a5c4417eb759e6322707ee2ab0ecb595f"><div class="ttname"><a href="classRenderer.html#a5c4417eb759e6322707ee2ab0ecb595f">Renderer::renderFrame3D</a></div><div class="ttdeci">void renderFrame3D(const Transform &amp;transform)</div><div class="ttdoc">Render a 3D frame with the current model/view/projection matrices.</div><div class="ttdef"><b>Definition:</b> renderer.cpp:235</div></div>
<div class="ttc" id="aclassRenderer_html_a7e13393392708399974fd1c6fcaf56cb"><div class="ttname"><a href="classRenderer.html#a7e13393392708399974fd1c6fcaf56cb">Renderer::setViewMatrix</a></div><div class="ttdeci">void setViewMatrix(const glm::mat4 &amp;view)</div><div class="ttdoc">Set the view matrix (world → camera transform)</div><div class="ttdef"><b>Definition:</b> renderer.cpp:103</div></div>
<div class="ttc" id="aclassRenderer_html_ae2535387a5c53cb9f04ba2599fe2a1c8"><div class="ttname"><a href="classRenderer.html#ae2535387a5c53cb9f04ba2599fe2a1c8">Renderer::setProjectionMatrix</a></div><div class="ttdeci">void setProjectionMatrix(const glm::mat4 &amp;proj)</div><div class="ttdoc">Set the projection matrix (camera → clip space transform)</div><div class="ttdef"><b>Definition:</b> renderer.cpp:107</div></div>
<div class="ttc" id="astructSimulationState_html_acef78e29043f3602fe7456343636eb07"><div class="ttname"><a href="structSimulationState.html#acef78e29043f3602fe7456343636eb07">SimulationState::model_matrix</a></div><div class="ttdeci">glm::mat4 model_matrix</div><div class="ttdoc">Model transformation matrix for rendering.</div><div class="ttdef"><b>Definition:</b> simulation_state.h:32</div></div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="autotoc_md387"></a>
Common Pitfalls and Solutions</h2>
<h3><a class="anchor" id="autotoc_md388"></a>
Problem: Black Screen</h3>
<p><b>Causes</b>:</p><ul>
<li>Forgot to bind VAO before drawing</li>
<li>Shader compilation failed (check with <code>glGetShaderiv</code>)</li>
<li>Uniforms not set</li>
<li>Depth test enabled but no depth buffer</li>
</ul>
<p><b>Solution</b>: </p><div class="fragment"><div class="line"><span class="comment">// Always bind VAO before drawing</span></div>
<div class="line">glBindVertexArray(vao);</div>
<div class="line">glUseProgram(shaderProgram);</div>
<div class="line"><span class="comment">// Set uniforms...</span></div>
<div class="line">glDrawElements(...);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md389"></a>
Problem: Vertices in Wrong Position</h3>
<p><b>Causes</b>:</p><ul>
<li>Matrix multiplication order wrong</li>
<li>Forgot to transpose matrix</li>
<li>Using radians vs degrees</li>
</ul>
<p><b>Solution</b>: </p><div class="fragment"><div class="line"><span class="comment">// Correct order: projection * view * model</span></div>
<div class="line">glm::mat4 mvp = projection * view * model;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// GLM uses radians</span></div>
<div class="line">glm::perspective(glm::radians(45.0f), aspect, near, far);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md390"></a>
Problem: Memory Leaks</h3>
<p><b>Causes</b>:</p><ul>
<li>Not deleting buffers/textures when done</li>
</ul>
<p><b>Solution</b>: </p><div class="fragment"><div class="line"><span class="comment">// In destructor or shutdown()</span></div>
<div class="line">glDeleteVertexArrays(1, &amp;vao);</div>
<div class="line">glDeleteBuffers(1, &amp;vbo);</div>
<div class="line">glDeleteBuffers(1, &amp;ebo);</div>
<div class="line">glDeleteProgram(shaderProgram);</div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="autotoc_md392"></a>
Performance Tips</h2>
<h3><a class="anchor" id="autotoc_md393"></a>
1. Minimize State Changes</h3>
<p><b>Bad</b> (slow): </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 1000; i++) {</div>
<div class="line">    glBindVertexArray(vao[i]);</div>
<div class="line">    glDrawElements(...);</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Good</b> (fast): </p><div class="fragment"><div class="line">glBindVertexArray(vao);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 1000; i++) {</div>
<div class="line">    <span class="comment">// Update uniforms if needed</span></div>
<div class="line">    glDrawElements(...);</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md394"></a>
2. Use Instancing for Repeated Objects</h3>
<div class="fragment"><div class="line"><span class="comment">// Draw 1000 cubes in one call</span></div>
<div class="line">glDrawElementsInstanced(GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0, 1000);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md395"></a>
3. Batch Similar Objects</h3>
<p>Render all opaque objects first, then all transparent objects.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md397"></a>
Debugging Tools</h2>
<h3><a class="anchor" id="autotoc_md398"></a>
1. glGetError()</h3>
<div class="fragment"><div class="line">GLenum err = glGetError();</div>
<div class="line"><span class="keywordflow">if</span> (err != GL_NO_ERROR) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;OpenGL Error: &quot;</span> &lt;&lt; err &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md399"></a>
2. Shader Info Log</h3>
<div class="fragment"><div class="line">GLint success;</div>
<div class="line">glGetShaderiv(shader, GL_COMPILE_STATUS, &amp;success);</div>
<div class="line"><span class="keywordflow">if</span> (!success) {</div>
<div class="line">    <span class="keywordtype">char</span> infoLog[512];</div>
<div class="line">    glGetShaderInfoLog(shader, 512, NULL, infoLog);</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Shader Error:\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md400"></a>
3. RenderDoc</h3>
<p>Download <b>RenderDoc</b> (free tool) to:</p><ul>
<li>Capture frames</li>
<li>Inspect all OpenGL state</li>
<li>See every draw call</li>
<li>Debug shaders</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md402"></a>
Next Steps</h2>
<ol type="1">
<li><b>Modify the cube</b>: Change colors in <code><a class="el" href="renderer_8cpp.html">renderer.cpp</a></code></li>
<li><b>Add more geometry</b>: Create a pyramid or sphere</li>
<li><b>Experiment with shaders</b>: Add lighting or textures</li>
<li><b>Learn about</b>: Textures, lighting, normal mapping</li>
</ol>
<h2><a class="anchor" id="autotoc_md403"></a>
Resources</h2>
<ul>
<li><a href="https://learnopengl.com/">LearnOpenGL</a> - Best OpenGL tutorial</li>
<li><a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/">OpenGL Reference</a> - Official docs</li>
<li><a href="https://www.shadertoy.com/">Shader Toy</a> - Fragment shader playground</li>
</ul>
<hr  />
<p><b>You now understand the core OpenGL concepts used in AeroDynControlRig!</b></p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="imgui_tutorial.html">ImGui Deep Dive Tutorial</a> for ImGui guide </dd>
<dd>
<a class="el" href="opengl_imgui_integration.html">OpenGL + ImGui Integration</a> for how they work together </dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
